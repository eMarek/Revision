\documentclass[a4paper, 12pt, twoside]{book}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% paketi
\usepackage[utf8x]{inputenc} % omogoča uporabo slovenskih črk kodiranih v formatu UTF-8 
\usepackage[slovene,english]{babel} % naloži, med drugim, slovenske delilne vzorce
\usepackage[pdftex]{graphicx} % omogoča vlaganje slik različnih formatov 
\usepackage[tmargin=3cm,rmargin=2cm,bmargin=3cm,lmargin=3cm]{geometry} % nastavi pravilne odmike
\usepackage{listings} % izvorna koda
\usepackage{pxfonts} % omogoča krepko pisavo v izvorni kodi
\usepackage[hyphens]{url} % url naslovi v virih

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% nastavitve
\renewcommand{\baselinestretch}{1.3} % ustrezen razmik med vrsticami
% \setcounter{tocdepth}{1} % globina kazala
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}} % prazne strani

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% izvorna koda
\lstset{
	basicstyle=\footnotesize\ttfamily, % pomanjšana pisava in monospace
	breaklines=true, % prelom vrstic
	captionpos=b, % napis na dnu
	frame=top, % črta zgoraj
	frame=bottom, % črta spodaj
	keywordstyle=\bfseries, % krepka pisava
	morekeywords={function, var, this}, % poudarjene besede
	numbers=none, % oznaka vrstice
	numberstyle=\tiny, % majcena pisava za oznake vrstic
	tabsize=2, % dva presledka zamika kode
	escapeinside={@}{@}, % koda znotraj afne se ignorira
	title=\lstname
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\selectlanguage{slovene}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% naslovna stran
\thispagestyle{empty}
\begin{center}
	{\large\sc Univerza v Ljubljani \par}
	{\large\sc Fakulteta za računalništvo in informatiko \par}
	\vskip 14em
	{\Large Marko Bregant \par}
	\vskip 1em
	{\huge\bf Operativna transformacija \par}
	\vskip 2em
	{\normalsize\sc DIPLOMSKO DELO \par }
	\vskip 0.8em
	{\normalsize\sc UNIVERZITETNI ŠTUDIJSKI PROGRAM PRVE STOPNJE \par }
	{\normalsize\sc RAČUNALNIŠTVO IN INFORMATIKA \par }
	\vfill
	{\large \textsc{Mentor}: doc. dr. Zoran Bosnić \par}
	\vskip 2em
	{\large Ljubljana, 2014 \par}
\end{center}

\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% izjava o intelektualni lastnini
\thispagestyle{empty}
\vspace*{11cm}
{\small \noindent Rezultati diplomskega dela so intelektualna lastnina avtorja in Fakultete za ra\-ču\-nal\-niš\-tvo in informatiko Univerze v Ljubljani. Za objavljanje ali izkoriščanje rezultatov di\-plom\-ske\-ga dela je potrebno pisno soglasje avtorja, Fakultete za ra\-ču\-nal\-niš\-tvo in informatiko ter mentorja.}

\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% originalni izvod izdane teme
\thispagestyle{empty}
\noindent 

\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% izjava o avtorstvu in soglasje
\thispagestyle{empty}
\vspace*{4cm}
\begin{center} 
	{\Large \textbf{\sc Izjava o avtorstvu diplomskega dela}}
\end{center}

\vspace{1cm}
\noindent Spodaj podpisani Marko Bregant, z vpisno številko \textbf{63080011}, sem avtor di\-plomskega dela z naslovom:

\vspace{0.5cm}
{\large \emph{Operativna transformacija}}

\vspace{1.5cm}
\noindent S svojim podpisom zagotavljam, da:
\begin{itemize}
	\item sem diplomsko delo izdelal samostojno pod mentorstvom doc.\ dr.\ Zorana Bosnića,
	\item so elektronska oblika diplomskega dela, naslov (slov., angl.), povzetek (slov., angl.) ter ključne besede (slov., angl.) identični s tiskano obliko diplomskega dela
	\item soglašam z javno objavo elektronske oblike diplomskega dela v zbirki “Dela FRI”.
\end{itemize}

\vspace{1cm}
\noindent V Ljubljani, dne 18. aprila 2014 \hfill Podpis avtorja:

\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% zahvala
\thispagestyle{empty}\mbox{}\vfill\null\it%
Za vso pomoč in nasvete pri izdelavi diplomske naloge se zahvaljujem mentorju doc. dr. Zoranu Bosniću. Zahvala gre tudi vsem sošolcem in prijateljem, ki so me tekom študija spodbujali. Še posebej pa bi se za podporo in bodrenje zahvalil družinskim članom in dragi Tini. \rm\normalfont

\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% kazalo
\def\thepage{} % na oštevilči poglavij pred "mainmater"
\tableofcontents{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% seznam uporabljenih kratic
\addcontentsline{toc}{chapter}{Seznam uporabljenih kratic}
\chapter*{Seznam uporabljenih kratic}
\begin{description}
    \item[DS] (Differential Synchronization) \\Diferenčna sinhronizacija, več v Poglavju \ref{sec:ds}.
	\item[OT] (Operational Transformation) \\Operativna transformacija, več v Poglavju \ref{sec:ot}.
	\item[WOOT] (WithOut Operational Transformation) \\Brez operativne transformacije, več v Poglavju \ref{sec:woot}.
	\item[AJAX] (Asynchronous JS and XML) \\Asinhroni JS in XML.
	\item[API] (Application Programming Interface) \\Vmesnik za programiranje aplikacij.
	\item[JS] (JavaScript) \\Programski jezik, ki omogoča izdelavo in prikaz dinamičnih spletnih strani. Z nastankom platforme \textbf{node.js} se ga vedno več uporablja tudi na strežniškem delu.
	\item[XML] (Extensible Markup Language) \\Razširljiv označevalni jezik. Njegovo popularnost izpodriva JSON.
    \item[JSON] (JavaScript Object Notation) \\Oblika zapisa podatkov, ki se večinoma uporablja za pošiljanje podatkov med odjemalcem in strežnikom.
	\item[SIGCE] (The Special Interest Group on Collaborative Computing) \\Skupina, ki promovira raziskovalce na področju CE.
    \item[CE] (Collaborative Editing) \\Sodelovalno urejanje ali skupinsko urejanje.
\end{description}

\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% povzetek
\addcontentsline{toc}{chapter}{Povzetek}
\chapter*{Povzetek}

Le malokdo si je v začetku razvoja interneta predstavljal, da bomo ljudje na oddaljenih lokacijah komunicirali instantno. Danes obstaja na spletu mnogo različnih orodij, ki omogočajo sodelovanje uporabnikov in rešujejo nek specifičen problem. Primer je urejanje golega besedila v realnem času. V naši diplomski nalogi smo raziskali protokole in algoritme na katerih temeljijo omenjena orodja. Po primerjavi njihovih lastnosti se je Operativna transformacija izkazala za najboljšo. V praktičnemu delu diplomske naloge smo tako implementirali enostaven spletni urejevalnik na osnovi Operativne transformacije. Urejevalnik je močno odvisen od majhnih sprememb, ki jih naredijo uporabniki in se razpošljejo drugim uporabnikom. Zaradi tega smo morali implementirati tudi algoritem za iskanje razlik v besedilu. Končni produkt je dosegljiv na \url{http://diploma.marek.si/}.\\

\textbf{Ključne besede:} sodelovanje v realnem času, urejevalnik, sočasnost, iskanje razlik v besedilu, Operativna transformacija


\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% abstract
\addcontentsline{toc}{chapter}{Abstract}
\chapter*{Abstract}
Hardly anyone in the early development of the internet imagined that people on remote locations will communicate instantly. Today there are various online tools that provide users collaboration and solve a specific problem. An example is editing plain text in real time. In our thesis we researched the protocols and algorithms underlying these tools. After comparing the characteristics the Operational transformation has proved to be the best. In the practical part of the thesis we implemented a simple web editor based on Operational transformation. Editor heavily dependents on small changes made by a user and sent to other users. Because of this reason we have needed to implement the algorithm used to find differences in the text. The final product is available on \url{http://diploma.marek.si/}.\\

\textbf{Keywords:} collaborationa in real time, editor, concurrency, finding differences in text, Operational transformation


\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mainmatter
\setcounter{page}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% uvod
\chapter{Uvod}

Še ne dolgo nazaj se nam je zdel internet počasen. Vse skupaj je delovalo zelo statično. Lahko bi rekeli, da smo dve desetletji nazaj splet uporabljali le za brskanje. Nato so se počasi pojavile spletne strani, ki so omogočale nekaj malega interaktivnosti. To so bile funkcionalnosti, kot so vpisovanje komentarjev, iskalniki, spletne galerije, forumi ... Danes se nam zdijo te funkcionalnosti že skoraj integrirane v spletnih aplikacijah. Lahko se ozremo nazaj in rečemo, da so bili to prvi zametki, ki so uporabnikom omogočili, da ustvarjajo splet, kot ga poznamo danes. Z nadgrajevanjem internetne infrastrukture so se povečale hitrosti prenosa podatkov. Z razvojem spletnih tehnologij se je izboljšala celotna uporabniška izkušnja. V zadnjih dvajsetih letih smo bili priča napredku tako na programski kot tudi na strojni opremi. Na tem mestu se je smiselno vprašati, kaj je bilo tisto bistveno, ki je celotno zadevo izboljšalo, in kako se bo izboljševala v prihodnosti. Internet v osnovi še vedno deluje po istem principu kot dvajset let nazaj. Imamo odjemalca (ang. client) na eni strani in imamo strežnik (ang. server) na drugi strani. Odjemalec vzpostavi komunikacijo s strežnikom. Od njega zahteva neko akcijo in le-ta jo izvrši. Gledano poenostavljeno, splet še danes deluje tako. Če pa pogledamo podrobno, so razlike ogromne. Komunikacija med odjemalcem in strežnikom, ter obratno, je omejena s svetlobno hitrostjo. Govorimo o prenosu podatkov v realnem času.

V okviru diplomske naloge bi radi preučili algoritme in raziskali celoten sistem, ki na spletu omogoča urejanje golega besedila v realnem času. Tega se bomo lotili tako, da bomo pregledali raziskave, ki so bile objavljene v akademski sferi. Leta 1989 so se pojavili prvi zapisi \cite{ccigs} o zagotavljanju vmesnika za deljno okolje  (ang. shared environment). V naslednjih nekaj letih so bile na tej podlagi predlagane nekatere izboljšave \cite{hllbw}. Kasneje je pri raziskavah precej pripomogla tudi ustanovitev SIGCE \cite{sigce}, ki promovira raziskovalce na tem področju. Skratka, preleteli bomo nekaj raziskav s tega področja. Po pridobljenem teoretičnem znanju bomo poiskali članke, ki so bili napisani s strani industrije. Radi bi izvedeli, kaj od teorije se lahko uporabi v praksi. Nekateri algoritmi, ki so bili na akademskem področju uspešni, so se implementirali v končnih ali v pol produktih. Največ uporabnih informacij bomo dobili od protokola Google Wave \cite{wave-ot}. Ne smemo pa pozabiti, da obstaja mnogo drugih uporabnih orodij \cite{share}, od katerih se lahko naučimo praktičnega dela. Cilj diplomske naloge je, da zasnujemo enega izmed algoritmov na plaformi \textbf{node.js} \cite{node}.  Ker hočemo doseči, da je algoritem na strežniškem delu kar se da neodvisen od odjemalcev, mora delovati kot API. Kot smo omenili, je uporabnost take izvedbe ravno v tem, da je neodvisen od odjemalcev, ki se nanj povezujejo, naj si bo spletna aplikacija ali mobilna naprava. Poleg tega tak način izvedbe spodbuja nadaljnji razvoj celotnega sistema na različnih odjemalcih.

Po uvodu bomo v drugem poglavju najprej predstavili problem in izzive sodelovanja v realnem času. V tretjem poglavju bomo preučili protokole in algoritme za sodelovanje v realnem času. V četrem poglavju jih bomo primerjali po njihovih lastnostih. V petem poglavju bomo poiskali algoritem za iskanje razlik v besedilu. V šestem poglavju bomo opisali našo implementacijo zasnove urejevalnike v realnem času. Na koncu, v sedmem poglavju, sledijo še sklepne ugotovitve.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Sodelovanje v realnem času}

Leta 2004 oziroma 2005 se je začela uveljavljati tehnologija AJAX. Njen glavni namen je, da odjemalcu omogoča pošiljanje asinhronih zahtev na strežnik. V praksi je bila razlika vidna v osveževanju spletnih strani. V preteklosti je brskalnik osvežil celotno spletno stran za vsako zahtevo, ki jo je naredil na strežnik. Uporaba AJAX-a pa omogoča, da so zahteve na strežnik manjše, bolj dinamične in najpomembnejše, asinhrone. Namesto celotne strani lahko osvežimo le manjši del. Lahko od strežnika zahtevamo ali mu pošljemo le nekaj podatkov. Kako pogosto delamo asinhrone zahtevke, ni pomemebno - naj si bo za vsako uporabnikovo interakcijo ali ponavljajoče z metodo pozivanja (ang. polling) \cite{diffsync} ali dolgega pozivanja (ang. long polling).

Naslednja pomembna stvar na spletu so spletne vtičnice (ang. WebSockets). Trenutno je še v povojih. Danes naj bi ga podpirali že vsi najnovejši brskalniki, vendar ga uporabljajo le redke spletne aplikacije. Sprememba, ki jih prinašajo spletne vtičnice, je način komunikacije med odjemalcem in strežnikom. Omogoča dvosmerno komunikacijo \cite{wave-cs}. Po novem lahko tudi strežnik pošilja zahtevo odjemalcu.

Ti dve tehnologiji omenjamo zato, ker sta in bosta največ prispevali k izboljšanju uporabniške izkušnje na spletu. Interakcija med odjemalcem in strežnikom je postala bolj tekoča, kot je bila v preteklosti. Z njo nam je bila dana možnost za razvoj orodij za sodelovanje v realnem času (ang. real-time collaboration tools). Obstaja že mnogo orodij, ki preko sodelovanja (ang. collaboration) rešujejo nek specifičen problem. Na podoben problem smo naleteli tudi sami, in sicer urejanje besedila v realnem času. Z urejanjem besedila nimamo v mislih označevanje besedila s krepko, ležečo, podčrtano pisavo in tako naprej, ampak za urejanje golega besedila kot takega. Uporabnik lahko doda ali pobriše črko, se pravi, operira z manjšimi enotami (črke, besede), ki se združujejo v večje enote (stavki, povedi, sporočilo, besedilo, dokument). Sistem mora skrbeti za izmenjevanje nastalega besedila med udeleženci \cite{gdocs23}. Na tak način delujejo spletna klepetalnica. Udeleženci v pogovoru si izmenjujo sporočila, naj bodo to večja ali manjše enote. Sistem mora le skrbeti, da se le-te pravilno prenesejo med udeležence pogovora. Vendar zadeva ni niti približno tako enostavna. Bistvena razlika urejevalnika v realnem času v primerjavi s spletno klepetalnico je v obliki hranjenja in operiranja nastalih podatkov. Pri spletnih klepetalnicah se vsako posamezno sporočilo na strežniku hrani kot samostojno enoto, ki se jo v celoti razpošlje med udeležence. Pri urejevalnikih besedila v realnem času pa je besedilo, ki ga udeleženci urejajo, enotno za vse udeležence hkrati. Zaradi razumljivosti bomo v nadaljevanju besedilo, ki ga urejajo uporabniki, poimenovali dokument. Lahko bi rekli, da vsak udeleženec ureja svoj lokalni dokument, preko katerega nastaja skupni dokument. Posamezne manjše enote besedila, ki se izmenjujejo med udeleženci, so le koščki celotnega dokumenta. Pred tako nastalim dokumentom mora delovati algoritem, ki zna te manjša enote besedila združevati v dokument \cite{gdocs22}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sočasnost in konsistentnost}
\label{sec:con}

Da bo problem razumljiv tudi najmanj veščemu poznavalcu tehnologij, bomo problem predstavili na konkretnem primeru \cite{problem} med dvema udeležencema (ang. participants) oziroma uporabnikoma.

Predstavljajmo si uporabnika Aljo in Bineta, ki za nakupovanje pripravljata skupni nakupovalni listek. Trenutno imata na seznamu mleko, kosmiče in piškote. To so stvari, ki jih običajano kupita vsako soboto. Alja se odloči, da bo ta vikend namesto piškotov kupila sadje, zato uredi seznam tako, da piškote zamenja s sadjem. Aplikacija spremembe pošlje tudi Binetu, ki nato vidi piškote zamenjane s sadjem. Bine se odloči, da bi tokrat raje kupil čokolado, zato temu primerno spremeni seznam. Aplikacija pošlje Binetove spremembe Alji, ki sedaj vidi sadje, zamenjano s čokolado. Nezadovoljna Alja se z Binetom dogovori za kompromis in doda sadje na seznam, tako da Binetova čokolada še vedno ostane na seznamu. Alja kot Bine imata sedaj na seznamu mleko, kosmiče, čokolado in sadje, kot je prikazano na koncu Slike \ref{problem1}.

\pagebreak

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=16cm]{problem1.png}
\end{center}
\caption{Diagram sočasnega urejanja nakupovalnega listka, pri čemer mora Alja dvakrat vpisati svojo željo po sadju. Njena prva sprememba ni dosegla pravilnega učinka ali povedano drugače, namen prve spremembe (ang. intention preservation) ni bil ohranjen \cite{sigce}.}
\label{problem1}
\end{figure}

Pri tako fleksibilni interakciji lahko nastane konflikt. Alja bi lahko spremenila piškote v sadje sočasno, kot bi Bine spremenil piškote v čokolado. V primeru optimističnega nazdora sočasnosti (ang. optimistic concurrency control) bi oba svoje spremembe videla takoj \cite{hllbw}. Vendar Aljine spremembe potrebujejo nekaj časa, da pridejo do Bineta. Tudi Binetove spremembe potrebujejo nekaj časa, da pridejo do Alje. Ta zamuda lahko spremeni vrstni red Aljine in Binetove spremembe, kar povzroči nakonsistentnost, kot je to prikazano na Sliki \ref{problem2}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{problem2.png}
\end{center}
\caption{Diagram sočasnega urejanja nakupovalnega listka. Vprašaji v zadnjem koraku pomenijo, da je seznam v konfliktu in mora biti razrešen. }
\label{problem2}
\end{figure}

\pagebreak

Predstavljajmo si enostavno rešitev za posodabljanja nakupovalnega listka, ki Alji in Binetu vedno pokaže zadnjo spremembo, ki je bila narejena na seznamu. Alja bi piškote spremenila v sadje, nato pa bi prišla Binetova sprememba v čokolado. Na drugi strani je Bine piškote spremenil v čokolado, nato pa bi sprejel Aljino sadje. V tem primeru bi imela Alja in Bine na koncu dva različna seznama, česar sploh ne bi opazila. Primer slabega reševanja konfliktov je prikazan na Sliki \ref{problem3}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{problem3.png}
\end{center}
\caption{Diagram sočasnega urejanja nakupovalnega listka. Konflikt v zadnjem koraku je rešen na način, da Alja in Bine sprejmeta zadnjo narejeno spremembo. Rešitev je slaba, saj ne zagotavlja konsistentnosti. }
\label{problem3}
\end{figure}

Osnovna ideja vzdrževanja konsistentnosti je v konvergenci (ang. convergence), ki zagotavlja, da so replicirane kopije dokumentov identične na vseh lokacijah, ko so v mirovanju \cite{wiki}.

Med drugim sta značilnosti sistemov za skupinsko delo v realnem času \cite{ccigs} tudi nestanovitnost (ang. volatile) in visoka stopnja interaktivnosti (ang. highly interactive). Prvo pomeni, da se lahko uporabnik urejanju kadarkoli pridruži ali ga zapusti. Druga značilnost pa narekuje kratke odvizne čase. Še večji problem tako nastane pri sodelovanju večih uporabnikov in s še večjo zamudo pri dostavi sprememb na nakupovalnem listku. Recimo, da se Alji in Binetu pridruži še Cene. Bine ima počasen internet. Alja in Cene na seznam dodata in odstranita deset novih artiklov, še preden Bine dobi eno spremembo. Medtem ko Bine ureja svoj seznam, so spremembe Alje in Ceneta še na poti k njemu. Za zagotovitev konsistentnosti bi morala aplikacija upoštevati zakasnjene oddaljene spremembe na osnovi prvotne verzije nakupovalnega listka.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Protokoli in algoritmi}
\label{chp:protalg}

Kako zagotoviti konsistentnost med oddaljenimi uporabniki pri sočasnem urejanju, je eden izmed glavnih izzivov naše diplomske naloge. V tem poglavju bomo raziskali protokole, ki omogočajo sodelovanje uporabnikov v realnem času in teoretično rešujejo omenjena problema. Najbolj razširjeni so Diferenčna sinhronizacija (ang. Differential synchronization), Operativna transformacija (ang. Operational transformation) in protokol Brez operativne transformacije (ang. Without operational transformation), bolj znan pod kratico WOOT.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Diferenčna sinhronizacija}
\label{sec:ds}

Diferenčna sinhronizacija (v nadaljevanju DS) je metoda, s katero ohranjamo dokumente sinhronizirane. Z njo se je ukvarjal Neil Fraser \cite{diffsync}. Kot opisuje, so konceptualno enostavni načini sinhronizacije zaklepanje (ang. locking), prenašanje dogodkov (ang. event passing) in trosmerno združevanje (ang. three way merge).

\begin{description}
	\item[Zaklepanje] je najenostavnejši način. Ko uporabnik odpre skupni dokument, se mu dodeli pravica lastnika (ang. ownership). Le on ga lahko ureja. Vsi ostali uporabniki lahko v tistem času dokument gledajo (ang. read-only access). Cilj je delno dosežen. Vsi uporabniki imajo sinhroniziran dokument, vendar se njegovo urejanje ne izvaja v realnem času. Izboljšava zaklepanja je delno zaklepenje, pri katerem se uporabniku dodeli pravica lastnika le za majhen del dokumenta. Ta način ni najboljši, kadar imajo uporabniki slabo povezavo. Paket z informacijo o zaklepanju in odklepanju se lahko izgubi. V dokumentu lahko nastanejo deli, nad katerimi ima lahko več uporabnikov pravico lastnika. Pojavijo se tudi druge anomalije.
	\item[Prenašanje dogodkov] temelji na zaznavanju vseh interakacij, ki jih naredi uporabnik z urejevalnikom, ter njihovo pošiljanje drugim uporabnikom. V teoriji je to enostavno, saj vsak sistem omogoča zaznavanja tipkanja. V praksi je težko izvedljivo. Poleg tipkanja lahko uporabnik naredi tudi operacije, kot so: izreži besedilo, prilepi besedilo, povleci in spusti besedilo, zamenjava besedila ... Operaciji, kot sta samodokončanje in pravopisni popravek, lahko naredi tudi sam urejevalnik. Kaj narediti v teh primerih? Težava je tudi v tem, da lahko pride zaradi neke napake ali zamude v komunkaciji do dveh popolnom različnih dokumenetov, ki jih ne moremo poenotiti. Tak način sinhronizacije ne moremo implementirati brez algoritma, ki bi reševal težavo pri zamudi prenašanja dogodkov.
	\item[Trosmerno združevanja] uporabljajo programerji pri delu na skupnem projektu. Je zelo robusten sistem, sestavljen iz treh korakov. Uporabnik najprej svojo vsebino pošlje na strežnik, ki izvzame narejene spremembe in jih združi s spremembami drugih uporabnikov. Nova kopija dokumenta se sinhronizira vsem uporabnikom. Sistem trosmernega združevanja ima nekaj slabosti. Če naredi uporabnik spremembo na dokumentu, medtem ko je sinhronizacija v teku, mora zavreči vse na novo narejene spremembe. Slabost je, da uporabnik ne dobi nobene povratne informacije (ang. feedback) med tipkanjem. Način trosmernega združevanja bi pri urejanju v realnem času deloval le v dveh primerih. Če bi si lahko privoščili, da bi uporabnika blokirali in sinhronizirali z novo verzijo na strežniku ali pa v primeru, da bi uporabnika sinhronizirali, ko neha tipkati. Ampak nobena od teh dveh variant ni urejanje dokumenta v realnem času.
\end{description}

Ker nobena izmed naštetih rešitev sinhronizacije ni zadovoljiva, si oglejmo DS bolj podrobno. DS je simetričen algoritem, ki uporablja neskončno ciklov razlik na dokumentih in z njimi popravlja ostale dokumente v ciklu. Najprej bomo preučili osnovno topologijo DS, ki je teoretična podlaga za izboljšave z metodo dveh senc in z metodo garantirane dostave.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Osnovna topologija}

Na Sliki \ref{ds1} je z diagramom prikazana DS. V osnovni topologiji obstajata dokument uporabnika in dokument računalnika. Oba sta locirana na istem sistemu brez internetne povezave. Med njima se nahaja dokument, imenovan skupna senca (ang. common shadow). Predvidimo, da imajo na začetku vsi trije dokumenti isto vsebino. Cilj je, da so dokumenti vseskozi čim bolj enaki. Ostale entitete so še razlika, sprememba in popravek. Razlika je signal, ki pove, da se dokument uporabnika razlikuje od skupne sence. Na ta način vemo, da je uporabnik naredil spremembo na svojem dokumentu. Ni nam potrebno spremljati vsake uporabnikove operacije. Ko se ve, kakšne spremembe so bile narejene, se mora dokument prekopirati v senco. Sprememba se pošlje v smeri računalnika. Na dokumentu računalnika se naredi popravek. Proces se ponovi še v smeri računalnika proti uporabniku. Vsi trije dokumenti so sinhronizirani.

Sistem je zanesljiv. Težava je, da taka zasnova ne omogoča sodelovanja oddaljenih uporabnikov v realnem času, saj vse skupaj poteka na enem sistemu.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=9.2cm]{ds1.png}
\end{center}
\caption{Osnovna topologija Diferenčne sinhornizacije.}
\label{ds1}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Metoda dveh senc}

Konceptualno še vedno ostajamo pri istem algoritmu. Razlika je v topologiji. Namesto skupne sence uporabimo senco uporabnika in senco strežnika, ki se s popravki posodabljata ločeno. Taka zasnova DS omogoča sodelovanje oddaljenih uporabnikov. Vsak uporabnik je na svojem sistemu. Uporabnike povezuje centralni strežnik. Zaradi enostavnosti razlage je na Sliki \ref{ds2} prikazan le en uporabnik in strežnik, ki sta ločena s črtkano črto. Po vsakem ciklu morata biti dokument uporabnika in dokument strežnika identična.

Predvidimo, da so na začetku vsi dokumenti v konsistentnem stanju. Uporabnik začne tipkati. Vključi se signal, da je med dokumentom in senco uporabnika razlika. Ko je znano, kakšne spremembe so bile narejene, se mora dokument prekopirati v senco. Sprememba se pošlje strežniku. Na strežniku se naredita dva popravka, na senci in na dokumentu. Pomembno je, da se popravek na senci izvede brez problemov. Na dokumentu se naredi nejasen (ang. fuzzy) popravek, ki izvira iz sodelovanja med uporabniki. Če naredi eden izmed uporabnikov korenito spremembo na dokumentu, povzroči, da se popravek prvega uporabnika ne umesti v dokument tako, kot bi si on želel. Nepredvideno stanje se reši v naslednji polovici cikla. Senca in dokument strežnika sta v tem trenutku različna. Ko je znano, kakšne so spremembe med senco in nepredvidenim dokumentom strežnika, se mora dokument prekopirati v senco. Sprememba se pošlje uporabniku. Ker je bila sprememba dokumenta strežnika narejena na podlagi sence strežnika, ki je bila ista kot senca in dokument uporabnika, se brez težav naredi popravek na senci in na dokumentu uporabnika. Dokumenti so sinhronizirani.

Sistem omogoča sodelovanje oddaljenih uporabnikov, vendar ni zanesljiv. Lahko se zgodi, da uporabnik na nezanesljivi povezavi od strežnika ne dobi nobenega odgovora. Do izgube spremembe lahko pride v prvem ali v drugem delu cikla. Senca uporabnika in senca strežnika nista več sinhronizirani. Edina rešitev za povrnitev nastalega stanje je, da povozimo uporabnikove spremembe. Tega si nihče ne želi.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=11.83cm]{ds2.png}
\end{center}
\caption{Diferenčna sinhronizacija z metodo dveh senc.}
\label{ds2}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Metoda garantirane dostave}

DS z metodo garantirane dostave je nadgradnja metode dveh senc. Iz Slike \ref{ds3} lahko razberemo, da se je topologija razširila še z varnostnima kopijama sence uporabnika in sence strežnika. Tudi tokrat mora biti vseh šest dokumentov v konsistentnem stanju. Namesto ene same spremembe se lahko pošlje več sprememb hkrati. V topologiji so nove tudi številke verzij. S črko {\tt n} je označena številka verzije uporabnika, s črko {\tt m} pa številka verzije strežnika. Na začetku sta obe številki verzij enaki {\tt 0}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=16cm]{ds3.png}
\end{center}
\caption{Diferenčna sinhronizacija z metodo garantirane dostave.}
\label{ds3}
\end{figure}

Delovanje DS z metodo garantirane dostave bomo razložili na primeru. V vseh dokumentih se nahaja beseda “{\tt avto}”. Alja v svoj dokument dopiše “{\tt mobil}”. Posledica razlike dokumenta uporabnika od sence uporabnika je sprememba “{\tt mobil}”. K sami spremembi se shrani številka verzije uporabnika, na podlagi katere je bila sprememba osnovana. V seznam sprememb se torej shrani {\tt \{ +mobil;n=0 \}}. V tem trenutku se Aljin dokument prekopira v njeno senco, poveča se številka verzije uporabnika na {\tt n=1}. Sprememba se pošlje strežniku. Poleg spremembe se strežniku pošlje tudi številka zadnje sinhronizirane verzije strežnika {\tt m=0}. Stanje je prikazano na Sliki \ref{ds4}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=16cm]{ds4.png}
\end{center}
\caption{Alja v svojem dokumentu vidi besedo avtomobil.}
\label{ds4}
\end{figure}

Strežnik primerja številki verzije uporabnika in strežnika spremembe s številkami verzije uporabnika in strežnika v senci strežnika (glej Sliko \ref{ds4}). Številki {\tt n} in {\tt m} sta v obeh primerih {\tt 0}, kar dovoljuje, da se naredi popravek na senci strežnika.

\pagebreak

Številka verzije uporabnika v senci strežnika se poveča na {\tt n=1}. Senca strežnika in senca uporabnika imata enako besedilo in enaki številki {\tt n} in {\tt m}, kar pomeni, da sta sinhronizirani. To se vidi tudi na Sliki \ref{ds5}. Popravek se naredi tudi na dokumentu strežnika, kar povzroči, da se senca strežnika prekopira v varnostno kopijo sence strežnika. Zakaj je to potrebno, bomo videli v nadaljevanju.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=16cm]{ds5.png}
\end{center}
\caption{Polovica cikla je končanega. Senci sta konsistentni.}
\label{ds5}
\end{figure}

Recimo, da uporabnik Bine na začetek dokumenta vpiše besedo “{\tt Moj}”. Na isti način kot Aljina sprememba se tudi njegova sprememba sinhronizira v dokument strežnika. Vsebina dokumenta strežnika je tako “{\tt Moj avtomobil}”.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=16cm]{ds6.png}
\end{center}
\caption{Server prejme Binetovo spremembo, ki jo mora poslati Alji.}
\label{ds6}
\end{figure}

Razlika med dokumentom strežnika in senco strežnika je sprememba “{\tt Moj}” osnovana na številki verzije strežnika {\tt 0}. Sprememba {\tt \{ +Moj;m=0 \}} se mora poslati Alji. Poleg nje se mora poslati tudi {\tt n=1}, s katerim strežnik potrjuje, da je sprejel zadnjo Aljino spremembo. Pred tem je potrebno dokument strežnika prekopirati v senco strežnika. Številka verzije strežnika {\tt m} v senci strežnika se poveča na {\tt 1}, Slika \ref{ds6}.

Sedaj lahko nadaljujemo z drugim delom cikla iz smeri strežnika proti Alji. Zaradi slabe povezave Alja ne prejme spremembe {\tt \{ +Moj;m=0 \}} iz strežnika. Tega niti ne opazi, ampak tipka naprej. V svoj dokument doda klicaj. Ponovi se postopek, podoben prvemu ciklu. K seznamu sprememb se doda {\tt \{ +!;n=1 \}}. Aljin dokument se prekopira v njeno senco, {\tt n} se poveča na {\tt 2}. Obe spremembi se pošljeta strežniku. Spomnimo se, da za prvo spremembo Alja ni dobila nobenega odgovora. Številka zadnje sinhronizirane verzije strežnika je še vedno {\tt m=0}. Slika \ref{ds7} prikazuje nastalo situacijo.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=16cm]{ds7.png}
\end{center}
\caption{Alja ni sprejela strežnikovih sprememb. V svojem dokumentu je naredila novo spremembo.}
\label{ds7}
\end{figure}

Strežnik sprejme Aljini spremembi. Najprej poskuša sprocesirati prvo spremembo {\tt \{ +mobil;n=0 \}}. Ker se številka zadnje sinhronizirane verzije strežnika {\tt m=0} ne ujema s številko verzije strežnika v senci strežnika, se senca strežnika povrne iz kopije sence strežnika (s številko {\tt m=0}), v katerem se nahaja “{\tt avtomobil}”. Strežnik poskusi ponovno sprocesirati prvo spremembo. Številki verzije strežnika {\tt m=0} se ujemata. Številka verzije uporabnika je v prvi spremembi {\tt n=0}, v senci strežnika pa {\tt n=1}. To pomeni, da je strežnik v enem izmed prejšnjih ciklov že obdelal to spremembo, zato jo lahko ignorira. Strežnik nato poskusi sprocesirati drugo spremembo {\tt \{ +!;n=1 \}}. Številki {\tt n=1} in {\tt m=0} se tokrat ujemata. Strežnik lahko naredi popravek na senci strežnika. Številka {\tt n} se poveča za {\tt 1} na {\tt n=2}. Popravek se nato naredi tudi na dokumentu strežnika, naredi pa se tudi kopija sence strežnika. Senca uporabnika in senca strežnika sta sinhronizirani.

\pagebreak

Opomba! Ko se je naredila povrnitev kopije sence strežnika, se je seznam strežniških sprememb pobrisal. Spremembe v dokumentih in številkah {\tt n} in {\tt m} vidimo na Sliki \ref{ds8}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=16cm]{ds8.png}
\end{center}
\caption{Alja je strežniku poslala že dve spremembi.}
\label{ds8}
\end{figure}

Dokument strežnika in senca strežnika se na Sliki \ref{ds8} razlikujeta. Strežnik pogleda, kakšne so spremembe na dokumentu. Tako kot v prvem ciklu najde spremembo \linebreak {\tt \{ +Moj;m=0 \}}. Sprememba se ponovno pošlje Alji. Tokrat je številka verzije uporabnika v senci dnevnika enaka {\tt 2}, zato se Alji poleg spremembe pošlje tudi {\tt n=2}. Še prej se dokument prekopira v senco in v senci strežnika se poveča številka verzije strežnika iz {\tt m=0} nazaj na {\tt m=1}.

Če bi bil strežnik spet neuspešen pri pošiljanju svojih sprememb, bi se seznam Aljinih sprememb povečeval, vse dokler ne bi dobila odgovora od strežnika. Recimo, da tokrat strežniku uspe in Alja prejme spremembo {\tt \{ +Moj;m=0 \}}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=16cm]{ds9.png}
\end{center}
\caption{Strežnik pošilja Alji potrditev njenih sprememb in spremembo Bineta.}
\label{ds9}
\end{figure}

Tokrat Alja primerja številke verzij. Številka verzije uporabnika v spremembi in v senci uporabnika je {\tt n=2}. Številka verzije strežnika v spremembi in v senci je {\tt m=0}. Sprememba je primerna za popravek na senci uporabnika. Naredijo se naslednje akcije. Na senci uporabnika se naredi popravek. Številka verzije zadnje sinhronizacije s strežnikom se v senci uporabnika poveča na {\tt m=1}. Popravek se naredi na dokumentu strežnika. Naredi se kopija sence uporabnika. Številka verzije uporabnika v kopiji sence uporabnika se poveča na {\tt n=2}. Ker je Alja uspešno sprejela potrditev strežnika, da je sprejel vse Aljine spremembe do številke verzije uporabnika {\tt n=2}, se s seznama Aljinih sprememb pobrišejo vse spremembe, ki imajo številko verzije uporabnika manjšo od {\tt 2} ({\tt n<2}).

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=16cm]{ds10.png}
\end{center}
\caption{Konsistentno stanje dokumentov.}
\label{ds10}
\end{figure}

Kjub temu da je med sodelovanjem uporabnikov in strežnika prišlo do izpada v povezavi, so se dokumenti posinhronizirali. V njih na koncu piše “{\tt Moj avtomobil!}”. Razen v varnostni kopiji sence strežnika, ki je vedno en korak za sinhronizacijo, kar je tudi njen namen, piše “{\tt avtomobil!}”.

Pri razlagi postopka DS nismo omenjali konkretnih lokacij sprememb, ampak le kakšne so bile spremembe. Zavedati se moramo, da so pri implementaciji algoritma tudi te pomembne. O spremembah in iskanju razlik v besedilu bomo govorili v Poglavju \ref{chp:diff}.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Operativna transformacija}
\label{sec:ot}

Operativna transformacija (v nadaljevanju OT) se je prvič omenjala v članku Concurrency Control in Groupware Systems \cite{ccigs}. Pri Googlu so Operativno transformacijo vzeli za osnovno pri načrtovanju protokola Wave \cite{wave-ot}, ki se uporablja v Google Docs-ih, kar nakazuje na njeno uporabnost.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Osnovno delovanje}

Pri OT je dokument shranjen kot serija kronoloških sprememb (včasih poimenovanih tudi operacij), narejenih na dokumentu. Primer spremembe je {\tt \{ Vstavi ‘M’ @11 \}}, ki pomeni “v dokumentu na lokacijo 11 vstavi črko M” ali {\tt \{ Pobriši @3-7 \}}, ki pomeni “v dokumentu pobriši vse znake med lokacijo 3 in 7”. Obstajajo še druge vrste sprememb, kot so oblikovanje besedila, zaklep odstavka, razveljevitev spremembe ... Zaradi enostavnosti razlage se bomo osredotočili le na omenjena dva tipa sprememb. Ko uporabnik ureja besedilo, se njegove spremembe shranjujejo v revizijski dnevnik. Seveda hranimo tudi dokument kot zaključeno celoto znakov, vendar so pomembne spremembe, ki so bile narejene na tem dokumentu. Če se urejanju skupnega dokumenta pridruži nov uporabnik, mu iz revizijskega dnevnika ponovimo vse (od prve do zadnje) spremembe in že lahko sodeluje pri urejanju tako kot ostali uporabniki.

Glede na to, da poznamo revizijo vseh sprememb, narejenih na dokumentu, lahko preverimo, kaj je uporabnik imel v svojem urejevalniku, preden je naredil novo spremembo. Na ta način njegovo spremembo pravilno umestimo v skupno besedilo skupaj z ostalimi spremembami, ki so bile narejene medtem. Algoritem, ki skrbi za umeščanje ali združevanje (ang. merging) sprememb, se imenuje OT.

Poglejmo delovanje OT na primeru \cite{gdocs22}. Predpostavimo, da imamo dokument, v katerem se trenutno nahaja stavek “{\tt ENOSTAVNO KOT PASULJ}”, ki zasede dvajset lokacij (ali mest). Urejanju tega dokumenta se pridružita Alja in Bine.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=12cm]{ot1.png}
\end{center}
\caption{Bine naredi pet sprememb.}
\label{ot1}
\end{figure}

Če želi Bine spremeniti stavek v “{\tt ENOSTAVNO KOT KEKS}”, mora za to narediti pet sprememb, ki jih prikazuje Slika \ref{ot1}. Naj pripomnimo, da bi Bine lahko stavek spremenil tudi samo z dvema spremembama in sicer {\tt \{ Pobriši @15-20 \}} in {\tt \{ Vstavi ‘KEKS’ @15 \}}. Lahko bi pobrisal tudi vsako črko posebej. Tako bi bilo sprememb še več, kot jih je prikazanih na Sliki \ref{ot1}. Več o spremembah in iskanju razlik v besedilu bomo govorili v Poglavju \ref{chp:diff}. Zaradi enostavnosti razlage recimo, da je Bine naredil pet sprememb.

Predpostavimo, da, medtem ko Bine tipka, začne spreminjati stavek tudi Alja, in sicer v “{\tt TAKO ENOSTAVNO KOT PASULJ}”. Tudi Alja je naredila pet sprememb.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=12cm]{ot2.png}
\end{center}
\caption{Alja naredi pet sprememb.}
\label{ot2}
\end{figure}

Če bi Alja v naslednjem koraku naivno sprejela in izvršila Binetovo prvo spremembo, bi v stavku pobrisala napačne črke, kot je prikazano na Sliki \ref{ot3}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=12cm]{ot3.png}
\end{center}
\caption{Brez transformacije pride do nekonsistentnosti.}
\label{ot3}
\end{figure}

Alja je na začeteku stavka dopisala pet znakov, o katerih Bine še ni bil seznanjen. Lokacija Binetove spremembe je zato napačna glede na Aljino verzijo dokumenta. Da bi se izognili temu problemu, mora narediti Alja transformacijo Binetovih sprememb relativno na svoj lokalni dokument. V našem primeru mora Alja, ko sprejme Binetove spremembe, zamakniti lokacijo spremembe za pet znakov, kolikor jih je vpisala na začetku stavka. Sprememba {\tt \{ Pobriši @15-20 \}} se transformira v {\tt \{ Pobriši @20-25 \}}, kot je pravilno prikazano na sliki \ref{ot4}.

\pagebreak

Ko naredi Alja transformacijo in izvrši Binetovo prvo spremembo, dobi pravilen stavek.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=12cm]{ot4.png}
\end{center}
\caption{Z uporabo OT dobimo pravilen rezultat.}
\label{ot4}
\end{figure}

Ko transformira in izvede še ostale štiri spremembe, dobi končno verzijo dokumenta.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=12cm]{ot5.png}
\end{center}
\caption{Končna verzija dokumenta, ki ga vidi Alja.}
\label{ot5}
\end{figure}

Včasih spremembe ne povzročajo konfliktov in ni potrebe po transformaciji. Ko prejme Bine Aljine spremembe, ni potrebe po zamikanju lokacij. Bine mora izvesti Aljine spremembe točno take, kot jih je ona izvedla na svojem lokalnem dokumentu.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=12cm]{ot6.png}
\end{center}
\caption{Končna verzija dokumenta, ki ga vidi Bine.}
\label{ot6}
\end{figure}

Tako Alja kot Bine v svojem lokalnem dokumentu na koncu vidita stavek “{\tt TAKO ENOSTAVNO KOT KEKS}”. To ne bi bilo mogoče, če ne bi uporabili algoritma za zamikanje sprememb. Pravilno implementiran algoritem OT nam garantira, da imajo vsi uporabniki, ko prejmejo vse spremembe, isto verzijo dokumenta.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Protokol sodelovanja}
\label{subsec:ps}

Z uporabo OT smo se naučili, kako z zamikanjem lokacij sprememb dopustiti večim uporabnikom urejanje istega dokumenta brez konflikov. Še vedno pa obstaja težava, kako vsako spremembo pravilno združiti z drugimi spremembami, če se le-te zgodijo istočasno. Zagotoviti moramo, da vsak oddaljeni uporabnik ve, da obstajajo spremembe, ki morajo biti združene. Za to skrbi Protokol sodelovanja (ang. Collaboartion protocol). Tehnologiji OT in Protokol sodelovanja skupaj, znak za znakom, skrbita za sodelovanja v realnem času \cite{gdocs23}.

Zavedati se moramo, da za urejanje dokumenta v realnem času skrbijo tako strežnik kot odjemalci. Običajno so to spletni brskalniki uporabnikov. Pri urejanjeju dokumenta mora odjemalec sprocesirati vse spremembe, ki jih naredi uporabnik, in jih poslati na strežnik. Sprocesirati mora tudi vse spremembe drugih uporabnikov, ki mu jih pošlje strežnik. Seveda brez sodelovanja strežnika ne gre. Oglejmo si, katere podatke si morajo beležiti odjemalci in katere strežnik.

Vsak odjemalec si mora beležiti sledeče ...
\begin{description}
	\item[Številko zadnje sinhronizirane revizije] smo na Sliki \ref{pc1} označili s sivim krogcem in številko v njem.
	\item[Čakajoče spremembe] so spremembe, ki so bile narejene v odjemalcu in niso še bile poslane na strežnik.
	\item[Poslane spremembe] so spremembe, ki so bile poslane na strežnik, vendar jih strežnik še ni potrdil.
	\item[Trenutno stanje dokumenta] kot ga vidi uporabnik.
\end{description}

Na strežniku se shranjujejo tri stvari:
\begin{description}
	\item[Čakajoče spremembe] so spremembe, ki jih je strežnik sprejel, a jih še ni sprocesiral.
	\item[Revizijski dnevnik] je dnevnik, v katerem je celotna zgodovina sprememb.
	\item[Trenutno stanje dokumenta] kot bi ga morali v najkrajšem možnem času videti vsi uporabniki.
\end{description}

S hranjenjem in uporabo teh informacij je mogoče zasnovati komunikacijo med strežnikom in odjemalci tako, da so oddaljeni urejevalniki sposobni drug od drugega naglo sprocesirati spremembe.

Na vzorčnem dokumentu bomo predstavili, kako je poskrbljeno za komunikacijo med strežnikom in odjemalcem. Na Sliki \ref{pc1} predstavljata zunanja stolpce uporabnika Aljo in Bineta, ki urejata skupni dokument. Srednji stolpec je strežnik. Spremembe, ki jih naredita Alja in Bine in se pošljejo na strežnik, so označene v ovalni obliki. Transformacije, ki smo jih že spoznali, bodo na naslednjih slikah označene s peterokotnikom.

Alja začne tipkati “{\tt V}” na začetku dokumenta.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=14cm]{pc1.png}
\end{center}
\caption{Alja začne tipkati. Bine je v mirovanju.}
\label{pc1}
\end{figure}

Aljin urejevalnik si spremembo {\tt \{ Vstavi ‘V’ @1 \}} shrani med čakajoče spremembe. V naslednjem trenutku se ta pošlje na server ter se prestavi na seznam poslanih sprememb. Poleg same spremembe se strežniku pošlje tudi številka revizije in avtorja spremembe (uporabnika). Informacija o uporabniku je pomemba z vidika avtentikacije. O številki revizije bomo več povedali v naslednjih korakih. Glej Sliko \ref{pc1}, strežnik sprejme Aljino prvo spremembo in jo doda med čakajoče spremembe.

\pagebreak

Odjemalec lahko strežniku v enem pošiljanju pošlje tudi več črk za vstavljanje v dokument. Koliko črk hkrati bo poslanih, je odvisno od implementacije urejevalnika in algoritma za zaznavanje sprememb. Več o tem v poglavju \ref{chp:diff}.

Na Sliki \ref{pc2} vidimo, da Alja nadaljuje s tipkanjem in doda “{\tt \ slogi }” v svoj urejevalnik. Alja v svojem trenutnem dokumentu vidi “{\tt V slogi }”. V istem času Bine vpiše “{\tt je moč!}” v svoj prazen dokument. Ne pozabimo, da Bine še vedno ni prejel Aljinih sprememb.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=14cm]{pc2.png}
\end{center}
\caption{Alja nadaljuje s tipkanjem. Bine na drugi strani tudi začne pisati na začetku svojega dokumenta. Strežnik o tem še ni obveščen.}
\label{pc2}
\end{figure}

Aljin {\tt \{ Vstavi ‘ slogi ’ @2 \}} je bil dodan med čakajoče spremembe in še ni poslan na strežnik. Pravilo je, da strežniku nikoli ne pošiljamo več kot ene čakajoče spremembe naenkrat. Dokler Alja od strežnika ne dobi potrditve prve spremembe, bo njen urejevalnik vse nove spremembe hranil med čakajočimi spremembami. Na Sliki \ref{pc2} lahko opazimo, da si je server Aljino prvo spremembo že shranil v revizijski dnevnik.

\pagebreak

V naslednjem koraku, kot je to prikazano na Sliki \ref{pc3}, pošlje strežnik Binetu Aljino prvo spremembo ter Alji odgovori s potrditvijo, da si je zabeležil njeno spremembo v revizijski dnevnik.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=14cm]{pc3.png}
\end{center}
\caption{Strežnik procesira Aljino prvo spremembo.}
\label{pc3}
\end{figure}

Bine sprejme Aljino spremembo od strežnika. Z uporabo OT mora transformirati svojo čakajočo spremembo {\tt \{ Vstavi ‘je moč!’ @1 \}}. Ker je Alja na začetek dokumenta že vpisala “{\tt V}”, Binetov urejevalnik zamakne njegovo spremembo za eno lokacijo. Po tem procesu vstavi Binetov urejevalnik v trenutni dokument Aljino spremembo “{\tt V}” in posodobi številko zadnje sinhronizirane revizije na 1. Alja je medtem sprejela potrditev iz strežnika. Tudi ona posodobi številko zadnje sinhronizirane revizije na 1. Svojo spremembo odstrani s seznama poslanih sprememb.

V Aljinem trenutnem dokumentu se nahaja “{\tt V slogi }”, v Binetovem pa “{\tt Vje moč!}”, kar nakazuje, da še ni prejel vseh sprememb. Sledi pošiljanje čakajočih sprememb.

\pagebreak

Na Sliki \ref{pc4} se vidi, da oba uporabnika hkrati pošljeta spremembo, vendar sprejem strežnik Aljino pred Binetovo in jo zato tudi prej sprocesira. Njeno spremembo s seznama čakajočih sprememb prestavi v revizijski dnevnik. Pri tem mora le popraviti številko revizije, ki enolično označuje spremembo. Spomnimo se, da je Alja pri pošiljanju svoje spremembe poslala številko zadnje sinhronizirane revizije, številko 1. Strežnik na ta način ve, da je njena sprememba narejena na podlagi prve revizije. Ker se v revizijskem dnevniku pričakuje sprememba, ki je naslednja po vrsti, lahko njeno spremembo brez težav umesti v trenutni dokument.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=14cm]{pc4.png}
\end{center}
\caption{Istočasno sodelovanje Aljinega in Binetovega urejevalnika preko strežnika.}
\label{pc4}
\end{figure}

Sledi potrditev spremembe Alji s številko revizije 2. Binetu se pošlje novo spremembo. Kot na Sliki \ref{pc3} se začne tudi v primeru na Sliki \ref{pc5} izvajati OT v Binetovem urejevalniku. Ker nima nobene čakajoče spremembe, ni potrebe po uporabi OT. Aljina sprememba se vstavi v njegov dokument brez transformacije. Številka zadnje sinhronizirane revizije se Binetu poveča na 2. Ker strežnik Alji odgovori s potrditvijo, se tudi njej poveča številka zadnje sinhronizirane revizije na 2.

\pagebreak

OT se ne dogaja samo pri odjemalcih, ampak je nujna tudi na strežniku. Zakaj je temu tako, bomo ugotovi kmalu. Medtem ko se odjemalca ukvarjata z zahtevami strežnika (potrditev pri Alji in sprememba pri Binetu), je strežnik začel procesirati \linebreak Binetovo čakajočo spremembo {\tt \{ Vstavi ‘je moč!’ @2, Revizija 1, Uporabnik \linebreak Bine \}}. Bine je v času pošiljanja spremembe (Slika \ref{pc4}) verjel, da bo njegova sprememba nosila zapredno številko revizije 2. Vendar je strežnik že obdelal Aljino spremembo, ki jo je zapisal v revizijski dnevnik kot drugo spremembo. Strežnik mora z uporabo OT transformirati Binetovo spremembo, da jo bo lahko shranil kot revizijo 3.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=14cm]{pc5.png}
\end{center}
\caption{Strežnik uporabi OT pri obdelovanju Binetove spremembe.}
\label{pc5}
\end{figure}

Binetovo spremembo transformira glede na spremembe, ki so bile storjene, odkar je Bine zadnjič naredil sinhronizacijo s strežnikom. V našem primeru je bila narejena le Aljina sprememba {\tt \{ Vstavi ‘ slogi ’ @2 \}}, ki je povzročila zamik Binetove spremembe za 7 lokacij. Končna sprememba v revizijskem dnevniku izgleda kot {\tt \{ Vstavi ‘je moč!’ @9, Revizija 3, Uporabnik Bine \}}.

\pagebreak

Na koncu dobi Bine potrditev svoje spremembe in Alja prejme Binetovo spremembo. Številka zadnje sinhronizirane revizije se obema poveča na 3. V revizijskem dnevniku so 3 revizije. V tem trenutku imajo strežnik in oba urejevalnika isti dokument z vsebino “{\tt V slogi je moč!}”. Glede na to, da uporabnika nimata več čakajočih sprememb je to tudi končna verzija dokumenta, ki sta ga skupaj uredila uporabnika Alja in Bine.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=14cm]{pc6.png}
\end{center}
\caption{Uporabnika imata na koncu dokument z isto vsebino.}
\label{pc6}
\end{figure}

\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Brez operativne transformacije}
\label{sec:woot}

V tem poglavju bomo opisali protokol Brez operativne transformacije \cite{woot}, bolj znan pod kratico WOOT. Bil je narejen kot odgovor na kopleksnost OT. Rekli smo, da se \linebreak pri OT med uporabnike pošiljajo spremembe in lokacija sprememb, primer \linebreak {\tt \{ Vstavi ‘M’ @11 \}}. OT skrbi za pravilno transformacijo lokacij sprememb. Pristop WOOT je drugačen in ga je lažje razumeti. WOOT skrbi za pravilno razvrščanje sprememb oziroma operacij, kot se jih običajno poimenuje. Glavna razlika je v podajanju informacij. Lahko si predstavljamo, da kaže na vsak znak v dokumentu unikatni kazalec, to je identifikacijska številka. Med oddaljene uporabnike, ki sodelujejo pri urejanju dokumenta, se pošiljajo informacije, med katerima znakoma oziroma na kateremu znaku je bila narejena sprememba. Posebnost protokola WOOT je, da se znakov v dokumentu nikoli ne briše, le označi se jih kot nevidne.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Podatkovni model}
\label{subsec:pm}

Dokument pri WOOT je shranjen kot zaporedje znakov, predstavljenih z identifikacijskimi številkami (ang. identifier order). Zaporedje znakov besedila “{\tt Ubogi mucek!}” se prikaže kot na Sliki \ref{woot1}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=9cm]{woot1.png}
\end{center}
\caption{Prikaz zaporedja znakov v dokumentu.}
\label{woot1}
\end{figure}

Za vsak znak v dokumentu hranimo pet informacij: identifikacijsko številko (ang. ID), vidnost, vsebino znaka, prejšnji znak in naslednji znak. Identifikacijska številka je kazalec na znak in je sestavljena iz unikatne oznake dokumenta in lokalne ure oziroma števca. Primer identifikacijske številka je {\tt (558,3)}. Unikatna oznaka dokumenta je številka, ki predstavlja uporabnika. Ko uporabnik začne prvič urejati dokument, se mu ta številka dodeli ali si jo izbere sam na podlagi predhodnega preverjanja unikatnostni. Lokalna ura je števec, ki se uporabniku povečuje za vsak vpisan znak. Na ta način je vsak znak v dokumentu označen z unikatnim kazalcem. Vidnost nam pove, ali uporabnik vidi določen znak. Pri brisanju se vidnost postavi na 0, sicer pa je vidnost pozitivna. Vsebina znaka je črka ali številka, ki jo znak predstavlja. Prejšnji znak je identifikacijska številka levega soseda, naslednji pa identifikacijska številka desnega.

Poznamo tudi dva posebna znaka, ki označujeta konec in začetek dokumenta. Uporabljata se zato, da lahko prvemu znaku nastavimo prejšnjega in zadnjemu znaku naslednjega soseda. Alja in Bine na Sliki \ref{woot2} urejata dokument, v katerem se trenutno nahaja besedilo “{\tt Ubogi mucek!}”. Dokument bi bil pri Alji in Binetu shranjen kot zaporedje znakov od {\tt U} do klicaja.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=13cm]{woot2.png}
\end{center}
\caption{Dokument, shranjen po protokolu WOOT.}
\label{woot2}
\end{figure}

Znaka {\tt (00000)} in {\tt (11111)} označujeta začetek oziroma konec dokumenta. Za vse ostale znake se v stolpcih od leve proti desni hranijo identifikacijska številka, vidnost, vsebina, prejšnji ter naslednji sosed. Iz identifikacijskih številk vidimo, da je prvo besedo skupaj s presledkom napisala Alja z unikatno številko {\tt 217}. Drugo besedo skupaj s klicajem je napisal Bine. Njegov dokument je označen z unikatno števliko {\tt 558}. Vsak uporabnik bi si lahko shranjeval, katera unikatna številka predstavlja katerega uporabnika, vendar ni potrebno. Vse črke so vidne. Nobena črka do sedaj še ni bila pobrisana. Glede na oznake sosedov so črke pravilno razvrščene.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Operacije}

Osredotočili se bomo na operaciji “{\tt Vstavi}” in “{\tt Pobriši}”. Ko uporabnik generira operacijo, se operacija najprej integrira lokalno, nato se razpošlje vsem oddaljenim uporabnikom, ki sodelujejo pri urejanju. Ko jo sprejmejo, se integrira tudi njim v dokument.

Potreba po vnaprejšnji lokalni integracija izvira iz razvrščanja znakov. Na primer, ko uporabnik generira spremembo {\tt \{ Vstavi ‘a’ @10 \}}, se le-ta v uporabniškem vmesniku prikaže kot črka {\tt a} na lokaciji 10. Sprememba se mora pretvoriti v \linebreak {\tt \{ Vstavi ‘c’$\prec$‘a’$\prec$‘e’ \}}, ki pomeni, vstavi črko {\tt a} med črko {\tt c} in {\tt e}. Lokacija spremembe je tako definirana s svojima sosedoma in ne s konkretno številko lokacije. Pretvorba je prikazana poenostavljeno. V dejanskem algoritmu bi sosednja dva znaka označlil z njunima identifikacijskama števikama. Podobno kot vstavljanje se mora tudi brisanje pretvoriti WOOT protokolu primerno. Sprememba \linebreak {\tt \{ Pobriši @5 \}} pobriše znak na lokaciji 5. V primeru Alje in Bineta imamo na lokaciji 5 črko {\tt i}, zato moramo spremembo pretvoriti v {\tt \{ Pobriši ‘i’ \}}. Seveda je tudi ta primer poenostavljen, saj je tudi operacija brisanja vezana na identifikacijsko številko in ne na konkretno črko ali številko. Pomembno je poudariti, da znakov pri protokolu WOOT nikoli ne brišemo, ampak jih le skrivamo. Dokument je shranjen kot zaporedje uporabniku vidnih in uporabniku nevidinih znakov. Na ta način je razvrščanje spremembe vedno pravilno, saj je odvisno tudi od nevidnih znakov.

Alja in Bine želita stavek “{\tt Ubogi mucek!}” urediti v “{\tt Uboga muca!}”. Alja začne urejati drugo besedo in vstavi črko {\tt a}. Bine začne urejati prvo besedo in pobriše črko {\\ i}. Operaciji sta prikazani na Slikah \ref{woot3} in \ref{woot4}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=13cm]{woot3.png}
\end{center}
\caption{Generiranje in integracija vstavljanja črke. Zadnji znak (presledek), ki ga je Alja vstavila (na Sliki \ref{woot2}), ima identifikacijska številka {\tt (217,5)}. Črka {\tt a} zatorej dobi številko {\tt (217,6)}. Vstaviti jo želimo na mesto med črko {\tt c} in {\tt e}, ki imata identifikacijski številki {\tt (558,2)} in {\tt (558,3)}.}
\label{woot3}
\end{figure}

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=13cm]{woot4.png}
\end{center}
\caption{Generiranje in integracija brisanja črke. Na Sliki \ref{woot2} vidimo, da je identifikacijska številka črke {\tt i} enaka {\tt (217,4)}. Operacija se pošlje Alji.}
\label{woot4}
\end{figure}

V naslednjem koraku Bine vstavi črko {\tt a} z identifikacijsko številko {\tt (558,6)} na podoben način, kot je to naredila Alja na Sliki \ref{woot3}. Alja pa pobriše črki {\tt e (558,3)} in {\tt k (558,4)} v drugi besedi. Operacija je podobna kot na Sliki \ref{woot4}, ko je to storil Bine. Končni stavek v dokumentu lahko vidimo na Sliki \ref{woot5}.

Čeprav so v dokumentu shranjene vse črke, ki sta jih napisala Alja in Bine, se jima v urejevalniku kažejo le črke, ki so označene kot vidne. Na Sliki \ref{woot5} opazimo še eno zanimivost. Črka {\tt c (558,2)} ima kot naslednjega soseda shranjeno črko {\tt e (558,3)}. Pravi naslednji sosed pa je v bistvu črka {\tt a (217,6)}. Ta pojav je običajen, ni napaka, je le posledica integracije vstavljanja.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=13cm]{woot5.png}
\end{center}
\caption{Nekaj črk v dokumentu je skritih in jih Alja in Bine ne vidita.}
\label{woot5}
\end{figure}

V našem enostvanem primeru nismo omenjali čakalne vrste. Ko uporabnik sprejme operacijo, mora iti ta najprej preko preverjanje predpogojev za izvršitev. Če predpogoj ni izpolnjen, se itegracija operacije začasno prestavi nazaj med čakajoče operacije. Primer, da pogoj ni izpolnjen, je, ko uporabnik sprejme operacijo {\tt \{ Pobriši ‘M’ \}}, črka {\tt M} pa v njegovem dokumentu še ne obstaja. Operacija brisanja črke {\tt M} je prehitela vstavljanje črke {\tt M}. Operacija brisanja bo integrirana v naslednji iteraciji.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Točka-točka sodelovanje}

Protokola DS in OT, omenjena v prejšnjih podpoglavjih, temeljita na centralnih strežnikih in sta od njih odvisna. Za destribucijo vsebine so bolj učinkovita omrežja točka-točka (ang. peer-to-peer, kratica P2P). Ta potencial želimo izkoristiti tudi pri sodelovanju urejanja vsebine. Protokol WOOT je lahko implementiran popolnoma decentraliziran. Na primeru bomo videli, da ni odvisen od centralnih strežnikov.

Integracija brisanja pri oddaljenih uporabnikih je enostavna operacija. Pri njej se le postavlja vidnost na 0 ali 1. Pri integraciji vstavljanja pri oddaljenih uporabnikih lahko pride do problemov. Znak, ki se ga integrira, se mora postaviti direktno med dva sosednja znaka. Če so se na to mesto pred sprejemom operacije vrinili tudi znaki drugih uporabnikov, so potrebne primerjave z vrinjenimi znaki. Pomembno je, da se vedno izvede enaka strategija, ki zagotovi konsistentnost med uporabniki.

Našima dvema uporabnikoma se je pridružil uporabnik Cene. Vsi trije imajo v svojem urejevalniku dokument, v katerem piše “{\tt Uboga muca!}”. Vmes (za presledkom) bodo dopisali besedo “{\tt mala}”. Ker se želijo pri urejanju dokumenta tudi zabavati, se dogovorijo sledeče. Uporabnik Cene, ki se je urejanju pridružil zadnji, lahko vpiše dve črki, Alja in Bine pa vsak po eno črko. Vprašanje je, ali lahko na koncu dobimo pravilno oblikovan stavek “{\tt Uboga mala muca!}”.

Vsi hkrati začnejo urejati. Alja se odloči, da bo vpisala črko {\tt a}, ker je to začetnica njenega imena. Bine je skoraj prepričan, da bo Alja vpisala črko {\tt a}, zato sam raje vpiše črko {\tt l}. Cene zase ve, da bo vpisal črko {\tt a}, saj sta v besedi dve in je manj verjetnosti, da bo zamočil. Ko prejme Aljino črko {\tt a}, se odloči, da bo pred njo vpisal črko {\tt m} v upanju, da je ni vpisal že Bine. Na konec dopiše še črko {\tt a}, za katero je bil že prej odločen, da jo bo vpisal.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=13cm]{woot6.png}
\end{center}
\caption{Prikaz sodelovanja s protokolom WOOT preko omrežja točka-točka. Vsak od uporabnikov je vpisal svojo izbrano črko oziroma črki.}
\label{woot6}
\end{figure}

Poglejmo na Sliko \ref{woot6}, kaj se je zgodilo. Alja in Bine sta hkrati vpisala črki {\tt a} in {\tt l} pred začetek besede “{\tt muca}”. Nato se je aktiviral Cene in dodal še njegov prispevek s črkami {\tt m} in {\tt a}. Da je stavek brez pravopisnih napak, je na koncu Bine vpisal še presledek. Ker zadnja sprememba ni nič posebnega, jo pri razmišljanju odmislimo. Operacije, označene v pravokotnikih, so se integrirala najprej lokalno, nato pa so bile poslane naprej po omrežju. Puščice prikazujejo pošljanje operacije še drugima dvema uporabnikoma. Uporabniki so skupno naredili štiri vstavljanja črk {\tt m}, {\tt a}, {\tt l} in {\tt a}. Kljub temu da se pri nobenem uporabniku črke niso vstavljale v tem zaporedju, vsi na koncu vidijo isti pravilen rezultat.

Za študijo primera vzemimo Ceneta. Najprej je od Alje prejel, da mora med presledek in črko {\tt m} vpisati črko {\tt a}. Ker sam ni še nič urejal, je to operacijo integriral brez težav. Nato je naredil dve lokalni integraciji. Pred prej od Alje vpisani {\tt a} je vpisal črko {\tt m}, za njim pa črko {\tt a}. Ker je šlo za lokalno integracijo, jo je lahko izvedel brez težav. Cene je imel v tem trenutku v svojem dokumentu nesmiseln stavek “{\tt Uboga maamuca!}”. Nato je prejel Binetovo spremembo {\tt \{ Vstavi ‘ ’$\prec$‘l’$\prec$‘m’ \}}. Zmeden bralec bi lahko mislil, da je pravilna integracija črke {\tt l} na lokacijo 7. Nastal bi stavek “{\tt Uboga lmaamuca!}”. Res je, da Cene sprejme informacijo, da mora locirati črko {\tt l} med presledek in m, vendar je ta informacija podana z identifikaciskimi številkami in ne z alfanumeričnimi znaki, kot smo že omenili. Po premisleku nam je jasno, da mora biti črka {\tt l} integrirana med presledek in drugi {\tt m} v stavku, torej {\tt \{ Vstavi (217,5)$\prec$(558,7)$\prec$(558,0) \}}. Potemtakem so kar štiri možnosti, kam se lahko integrira {\tt l}. Nastanejo lahko variante:

\begin{itemize}
	\item {\tt Uboga lmaamuca!}
	\item {\tt Uboga mlaamuca!}
	\item {\tt Uboga malamuca!}
	\item {\tt Uboga maalmuca!}
\end{itemize}

Kako urejevalnik ve, kam ga mora postaviti? Da bomo lažje razrešili ta problem, si poglejmo Sliko \ref{woot7}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=13cm]{woot7.png}
\end{center}
\caption{Del Cenetovega dokumenta pred integracijo črke {\tt l}.}
\label{woot7}
\end{figure}

Prikazane so konfliktne črke v Cenetovem dokumentu tik pred integracijo črke {\tt l (558,7)}. Postopek je sledeč. Vzamemo seznam črk, ki so znotraj meje, med katere bi se moral integrirati {\tt l}. Dobimo črke {\tt m (609,0)}, {\tt a (217,7)} in {\tt a (609,1)}. Iz tega seznama odstranimo črke, ki imajo prejšnjega ali naslednjega soseda znotraj meje, med katere bi se moral integrirati {\tt l}. Ostane nam samo črka {\tt a (217,7)}. Primerjamo identifikacijski številki črke {\tt a} in črke {\tt l}. Ker je 217 manjše od 558, se bo črka {\tt l (558,7)} postavila desno od črke {\tt a (217,7)}. Primerjavo moramo nadaljevati z vsemi črkami do meje. Naslednja po vrsti je črka {\tt a (609,1)}. Ker je 558 manjše od 609, se bo črka {\tt l (558,7)} postavila levo od črke {\tt a (609,1)}. Primerjanje je zaključeno. Pravilna oblika stavka je “{\tt Uboga malamuca!}”.

Ko se integrira še Binetov presledek, dobimo “{\tt Uboga mala muca!}”. Po podobnem postopku dobita tudi ostala dva uporabnika dokument z isto vsebino.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Primerjava po lastnostih}

V Poglavju \ref{chp:protalg} smo spoznali glavne tri protokole in njihove algoritme za sodelovanje pri urejanju besedila v realnem času. Pozoren bralec je lahko ugotovil, da smo nekatere pomanjkljivosti določenega algoritma namenoma spustili. Na drugi strani pa bi lahko nekatere prednosti bolje poudarili. Namen tega poglavja je, da jih primerjamo po njihovih lastnostih in predstavimo tako njihovo negativno kot pozitivno plat.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Hranjenje dokumenta}

V vseh treh primerih vsak uporabnik ureja svoj lokalni dokument. Vendar je ta dokument skupen vsem uporabnikom. Ko uporabniki obmirujejo (nehajo tipkati ali kako drugače delati spremembe na dokumentu), bi se morali vsi dokumenti v najkrajšem možnem času poenotiti. Najsibo to preko centralnega strežnika v primeru DS in OT ali preko ostalih uporabnikov pri WOOT. Vsi uporabniki bi morali videti isti dokument, ne glede na to, kateri algoritem za sodelovanje v realnem času se uporablja. Obstaja pa bistvena razlika, kako je ta dokument v osnovi shranjen. Vprašamo se lahko, kaj se zgodi, ko se urejanju pridruži nov uporabnik. Na kakšen način se dokument, shranjen v svoji primarni obliki, prikaže v uporabniku berljivi (ang. human readable) obliki?

Pri DS se posamezen dokument za vse uporabnike hrani kot dokument strežnika. Za vsakega uporabnika, posebej pa na strežniku, obstajata še senca dokumenta strežnika in varnostna kopija sence strežnika. Na strani uporabnika imamo podobne tri dokumente, vendar so to lokalni dokumenti, ki se nahajajo pri uporabniku. Zanimivo je, da je dokument strežnika že v uporabniku berljivi obliki. Ko se urejanju pridruži nov uporabnik, mu v njegovem grafičnem vmesniku takoj prikažemo vsebino dokumenta. Zadaj je potrebno poskrbeti, da se pravilno inicializirata senca in kopija sence strežnika. Pri uporabniku pa se morajo postaviti vsi trije dokumenti.

Pri OT smo v Poglavju \ref{subsec:ps} zapisali, da morata za posamezen dokument tako strežnik kot uporabnik hraniti trenutno stanje dokumenta. Kar je shranjeno v trenutnem stanju dokumenta v odjemalcu, je to, kar uporabnik dejansko vidi. Vendar je pri OT poudarek na spremembah. Najpomembnejša stvar na strežniku je revizijski dnevnik dokumenta in je enoten za vse uporabnike. V njem so kronološko shranjene vse spremembe, ki so jih naredili uporabniki. Da dokument prikažemo novemu uporabniku, le ponovimo revizijski dnevnik od začetka do konca \cite{gdocs22}. Seveda se mora v uporabnikovem odjemalcu pripraviti, da si bo beležil spremembe in številko zadnje sinhronizirane revizije.

Pri primerjavi DS in OT lahko ugotovimo, da je hranjenje dokumenta v obeh primerih z nekaj modifikacijami precej podobno. Če bi dopolnili algoritem DS, da bi beležil spremembe, ki jih naredijo uporabniki, bi imeli tudi pri DS revizijski dnevnik dokumenta. Tudi na OT bi lahko naredili nekaj modifikacij. Novemu uporabniku bi kar takoj prikazali trenutno stanje dokumenta, kot ga hrani strežnik. Številko zadnje sinhronizirane revizije bi odjemalcu poslali posebej. Z omenjenima modifikacijama bi bilo hranjene dokumenta precej podobno.

WOOT temelji na protokolu točka-točka in ne uporablja centralnega strežnika. Da bi se urejanju pridružil nov uporabnik, mora biti za to poskrbljeno preko kakega drugega sistema ali preko souporabnika v obliki povabila (ang. request). Posebnost WOOT je tudi to, kako se uporabniku prikaže dokument. Kot smo omenili v Poglavju \ref{subsec:pm}, za vsak znak v dokumentu hranimo pet informacij. Ko želimo novemu uporabniku prikazati dokument v uporabniku berljivi obliki, se naredi ena iteracija preko vseh znakov. Pobrisanih znakov (označenih kot skritih) se uporabniku ne prikaže. Vse ostale znake se prikaže glede na to katero črko ali številko predstavljajo. V bistvu se ta iteracija naredi vedno, ko uporabnik naredi ali prejme spremembo v dokumentu. Le tako je lahko dokument vedno v pravi obliki.

Slabost WOOT v primerjavi z DS in OT je, da se znaki v dokumentu nikoli ne brišejo, le skrivajo se. V primeru, da se pri urejanju dokumenta med uporabniki veliko tudi briše, velikost dokumenta nenormalno raste.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Struktura porazdelitve}

Ko govorimo o strukturi porazdelitve, govorimo o arhitekturi omrežja. Poznamo model odjemalec-strežnik (ang. client-server) in model točka-točka (ang. P2P). Pri modelu odjemalec-strežnik vsak posamezen odjemalec (uporabnik) centralnemu strežniku pošilja zahteve, medtem ko si pri modelu točka-točka med seboj povezane točke (uporabniki) izmenjujejo vire brez uporabe centraliziranega strežnika \cite{p2p} \cite{c-s}. Njuna aritektura je prikazana na Sliki \ref{p2p_c-s}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=13cm]{p2p_c-s.png}
\end{center}
\caption{Na levi je model odjemalec-strežnik, na desni je model točka-točka.}
\label{p2p_c-s}
\end{figure}

Oba modela smo že omenili, ko smo opisovali izbrane tri protokole ter algoritme. Avtorji algoritma WOOT so se naslanjali na dejstvo, da je model točka-točka boljši za distribucijo vsebine. Ta potencial so želeli izkoristiti in tako WOOT v osnovi deluje na modelu točka-točka, čeprav bi ga bilo možno realizirati tudi na modelu odjemalec-strežnik. Za DS in OT smo rekli, da temeljila na modelu odjemalec-strežnik. Pri OT to ni čisto res. Hipotezo ovrže prvi članek o OT \cite{ccigs}, saj pravi: “Za sisteme za skupinsko delo v realnem času je značilno, da so porazdeljeni (ang. distributed). Na splošno ni mogoče domnevati, da so vsi udeleženci povezani z istim strojem ali da so v istem lokalnem omrežju.“ Glede na potrebe po rešitvi zapletenih stanj, ki lahko nastanejo, če poleg “{\tt Vstavi}” in “{\tt Pobriši}” dodamo še bolj zapletene spremembe, so se v naslednjih raziskavah OT \cite{hllbw} začele pojavljati rešitve, zasnovane na modelu odjemalec-strežnik. Izkazale so se za boljše, saj zmanjšujejo verjetnost napak pri zapletenih spremembah na dokumentu.

Torej imamo DS na modelu odjemalec-strežnik, OT na modelu odjemalec-strežnik pri zapletenih spremembah oziroma na modelu točka-točka pri enostavnih spremembah ter WOOT na modelu točka-točka ali na modelu odjemalec-strežnik. Vprašanje je, kaj je boljše. Od česa je sploh odvisno, kateri model je boljši? Če med sabo primerjamo modela po zanesljivosti (ang. reliability) in razširljivosti (ang. scalability), je model točka-točka zmagovalec. Pri razširljivosti je neomejen. Zanesljivost pa je zelo visoka. Če en souporabnik odpove, so na voljo še vsi ostali souporabniki, na katere se uporabnik lahko priklopi. Pri modelu odjemalec-strežnik je zgodba drugačna. Razširljivost je slaba, saj je število povezav na en strežnik omejeno mnogo. Tudi z zanesljivosti ni drugače. Ko odpove strežnik, odpovejo vsi souporabniki.

Ker sta DS in OT močno odvisni od modela odjemalec-strežnik, obstajajo raziskave \cite{diffsync} na temo izboljšanja zanesljivosti in razširljivosti. Ideja je, da med sabo povežemo več strežnikov, ki si izmenjujejo spremembe v dokumentu ravno tako, kot si jih izmenjujeta odjemalec in strežnik. Tako hkrati izboljšamo razširljivost in zanesljivost. Več uporabnikov se lahko pridruži urejanju. V primeru izpada enega strežnika, se lahko prevežejo na drugega.

Končna ugotovitev je, da so DS, OT in WOOT enakovredne po strukturi porazdelitve, saj sta model odjemalec-strežnik in model točka-točka primerljiva po zanesljivosti in razširljivosti.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Počasna povezava}

Vsi trije algoritmi zagotavljajo sodelovanje v realnem času. Nismo pa omenili, kaj se dogaja pri visoki latenci (ang. latency). Na primer, ko imajo uporabniki počasno povezavo ali ko je oddaljenost med uporabniki ekstremno velika.

DS je omejena na največ en sinhronizacijski paket v enem sinhronizacijskem ciklu v danem trenutku \cite{diffsync}. Uporabnik lahko v sinhronizacijskem paketu pošlje več sprememb. Vendar to problema ne reši. V primeru, da se uporabnik nahaja na Marsu, strežnik pa na Zemlji, je čas enega sinhronizacijskega cikla pol ure. To pomeni, da uporabnik pošlje svoje spremembe, potem pa kar pol ure ne dobi odgovora od strežnika. V tem času sicer lahko tipka v svoj dokument, vendar od strežnika ne dobi ne povratne informacije o uspšnem prejemu sprememb ne novih sprememb od drugih uporabnikov, kar je problem. Če naredijo ostali uporabniki korenite spremembe na skupnem dokumentu, se lahko zgodi, da se spremembe uporabnika na Marsu v zadnje pol ure pobrišejo brez možnosti povrnitve.

Podobno kot pri DS je tudi pri OT pravilo, da se na strežnik ne pošlje več kot ene čakajoče spremembe. Na sezamu poslanih sprememb je največ ena sprememba, ki še ni potrjena s strani strežnika. Algoritem za pošiljanje sprememb bi sicer lahko prilagodili, da bi poslal več sprememb v paketu, tako kot je to predvideno pri DS s sinhronizacijskim paketom. Prilagoditev bi bilo potrebno narediti tudi na strežniku, vendar ne reši problema pri počasni povezavi. Uporabnik na Marsu, ki bi pošiljal spremembe na Zemljo vsake pol ure, bi lahko dokument izmaličil za vse uporabnike. Kljub transformacijam se lahko v pol ure naredi preveč sprememb. Če uporabnik na Marsu naredi spremembo “{\tt Vstavi}” na isti lokaciji kot drug uporabnik na Zemlji, se bo želena lokacija spremembe transformirala v nezaželeno. Nastalo napako uporabnika hitro rešita, vendar uporabnik na Marsu potrebuje nadaljnje pol ure za popravek. Ponovno lahko pride do napake, če želita napako popraviti oba uporabnika. Skratka, pri počasni povezavi, bi bilo preveč napak.

Če sta DS in OT zelo odvisni od potrditev sprememb s strani strežnika, je pri WOOT precej drugače. Že v osnovi WOOT ne temelji na centralnem strežniku in se potrditev ne predvideva. Komunikcija je rešena kot stalen tok posodobitev med vsemi uporabniki. Poleg tega so spremembe vezane na identifikacijske številke, integracija sprememb pri oddaljenih uporanbikih pa ni odvisna od časa dostave. Če pa se že zgodi, da brisanje znaka prehiti vstavljanje znaka, potem se sprememba “{\tt Pobriši}” postavi v čakalno vrsto. Integrira se v enem od naslednjih integracij. V primeru enega uporabnika na Marsu in drugega uporabnika na Zemlji bo protokol vse spremembe brez težav pravilno integriral.

Pri visoki latenci je torej protokol WOOT boljši kot DS in OT. Po drugi strani pa se lahko vprašamo v čem je smisel implementirati sodelovanje v realnem času med uporabnikom na Marsu in uporabnikom na Zemlji. Zaradi velike oddaljenosti lahko dostava in odgovor paketa trajata pol ure. Nekako se zdi, da je nesmiselno uporabljati urejevalnik v realnem času, če je uporabnik na Marsu pol ure v zaostanku v primerjavi z ostalimi uporabniki na Zemlji. Teoretično je WOOT res boljši kot DS in OT, vendar je na Marsu ravno tako neuporaben kot ostala dva. Če bi že hoteli izboljšati uporabniško izkušnjo na Marsu, bi morali iskati rešitev v izboljšanju infrastrukture, ne pa v izboljšanju algoritma.

Na Zemlji so vsi trije algoritmi nekako enakovredni. Bolj problematičen od počasne povezave je izpad povezave, kar se ne zgodi redko. Uporabnik je o nedostavljenih spremembah obveščen preko časovne omejitve (ang. timeout). Kako to zgleda v praksi? Pri DS in OT se spremembe, ki po določenem času niso potrjene s strani strežnika, obravnavajo kot nedostavljene in se jih pošlje še enkrat. Pri WOOT pa je nekoliko drugače. Ker temelji na omrežju točka-točka, potrjevanje ni potrebno. Če se zgodi, da sprememba ni dostavljena, ni težav, sej korenito ne vpliva na vse nadaljnje spremembe. Vsi uporabniki imajo še vedno podoben dokument, le da nekomu kakšen del manjka. To pa se lahko reši s posebnim preverjanjem, ki preveri, ali je uporabnikov dokument konsistenten z dokumentom drugega uporabnika.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zaznavanje sprememb}

Pri razlagi protokolov za urejanje besedila v realnem času smo zapisali, da delajo uporabniki spremembe v besedilu. Osredotočili smo se na spremembi “{\tt Vstavi}” in “{\tt Pobriši}”, vendar obstajajo še druge, ki jih v diplomski nalogi nismo zajeli. Dejstvo pa je, da besede “sprememba” nismo nikoli natančno definirali. Govorili smo le o tem, da uporabnik naredi spremembo. Razlog je, da uporabljajo različni akademski člani različno terminologijo za poimenovanje uporabnikove interakcije z urejevalnikom besedila. Druga težava pa je, da predvidevajo različni protokoli različno zaznavanje sprememb in jih tudi različno obravnavajo.

Ko uporabnik ureja besedilo v svojem dokumentu, sta dve možnosti, ali zaznavamo vse njegove operacije preko poslušalcev dogodka (ang. event listeners) ali pa iščemo v besedilu nastale spremembe. Pri primitivnih implementacijah so bili poslušalci dogodkov precej popularni. Zaznavanje pisanja in brisanja golega besedila je precej enostavno na katerikoli platformi. Poleg tipkanja lahko uporabnik naredi tudi operacije, kot so: izreži besedilo, prilepi besedilo, povleci in spusti besedilo, zamenjava besedila, povrni besedilo ... Operaciji, kot sta samodokončanje in pravopisni popravek, lahko naredi tudi sam urejevalnik. Ko dodamo osnovnima dvema operacijama še bolj zapletene, postanejo poslušalci dogodkov preveč zapleteni. Včasih se jih niti ne da realizirati. Tako so se vedno bolj začeli uveljavljati algoritmi za iskanje razlik med besediloma. Kako delujejo, bomo opisali v Poglavju \ref{chp:diff}. Na tem mestu povejmo le to, da je njihov glavni namen iskanje sprememb v besedilu. Spremembe, ki jih algoritmi najdejo, so posledica uporabnikove interakcije z urejevalnikom. Njihova dobra lastnost je, da so v osnovi implementirani povsem neodvisno od uporabnika. Vseeno pa najdejo vse spremembe, ki nastanejo ob uporabnikovih operacijah v besedilu, in tudi vse spremembe, ki nastanejo ob operacijah samega urejevalnika.

Poglejmo si, kako je z obravnavanimi protkoli. Pri DS smo že v osnovni topologiji na Sliki \ref{ds1} omenili tri entitete, in sicer razliko, spremembo in popravek. To nakazuje, da predvideva DS uporabo algoritma za iskanje razlik v besedilu. Najdene spremembe se kot popravki uveljavijo na oddaljenem računalniku. Pri OT o nastanku sprememb nismo kaj dosti govorili, smo pa poudarili, da so spremembe njen pomemben del, saj je dokument shranjen kot revizijski dnevnik sprememb. Kako implementirati zaznavanje spremembe v praksi, je programerjeva odločitev. Potrebno je biti le pazljiv, da se že poslanih sprememb ne pošlje še enkrat. Pri WOOT se spremembe običajno imenujejo operacije, ker to v bistvu tudi so. Če se uporabnikove operacije zaznava preko poslušalcev dogodkov, je posamezna operacija tudi že sprememba. Na tak način pa naj bi WOOT tudi delovale. Urejevalnik mora biti sposoben zaznavati uporabnikove operacije kot spremembe, jih integrirati v lokalni dokument in jih poslati ostalim uporabnikom za integracijo v njihovih dokumentih.

Seveda bi se dalo tudi WOOT implementirati z algoritmom za iskanje razlik v besedilu. Vendar obstaja bistvena razlika v primerjavi z DS in OT. Pri DS in OT so spremembe, ki vključujejo več znakov skupaj, nekaj povsem običajnega. Pri WOOT pa je vsaka sprememba vezana na posamezen znak. Večznakovne spremembe bi vodile v napake pri delovanju. Recimo, da želimo besedo “{\tt pot}” spremeniti v besedo “{\tt pilot}”. Pri DS in OT bi strežniku poslali le eno spremembo, in sicer {\tt \{ Vstavi ‘il’ @2 \}}. Pri WOOT bi morali ostalim uporabnikom poslati dve spremembi, in sicer {\tt \{ Vstavi ‘p’$\prec$‘i’$\prec$‘o’ \}} in nato {\tt \{ Vstavi ‘i’$\prec$‘l’$\prec$‘o’ \}}. Drobljenje sprememb še dodatno zakomplicira implementacijo urejavalnika, zato se zdi, da je za WOOT bolj primerno uporabiti poslušalce dogodkov.

Ponovno ni konkretnega zmagovalca med protokoli glede zaznavanja sprememb. Po našem mnenju je pri DS in OT najbolj primerno uporabiti algoritme za iskanje razlik med besedilom, pri WOOT pa je bolj primerno uporabiti poslušalce dogodkov. Katerega je bolj smiselno implementirati, je odvisno od platforme in od predvidene dolžine besedila.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem sočasnosti}

O problemu sočasnosti smo govorili na začetku naše diplomske naloge v Poglavju \ref{sec:con}. Do težave pride, ko več uporabnikov v istem času na isti lokaciji naredi neko spremembo. Za vzdrževanje konsistentnosti potrebujemo algoritme za nadzor sočasnosti, kot so DS, OT in WOOT.  Algoritme za nadzor sočasnosti lahko klasificiramo kot pesimistične ali optimistične \cite{hllbw}. Pesimistični algoritem potrebuje vnaprej komunikacijo s centralnim strežnikom ali s souporabnikom. Ko uporabnik naredi spremembo, mora počakati na povratno informacijo ali je s spremembo vse v redu ali ni. Če ni težav, se uveljavi nova sprememba na dokumentu. Sicer mora uporabnik popraviti svojo spremembo in poskusiti ponovno. Optimistični algoritem deluje ravno nasprotno. V tem primeru uporabnik naredi spremembo in jo pošlje na strežnik ali souporabniku. Naloga strežnika oziroma souporabnika je, da to spremembo umesti v dokument na način, da se med souporabniki ohrani konsistentnost. Pesimistični nadzor pri urejanju golega besedila v realnem času ne pride v poštev. V praksi ga po navadi najdemo v kombinaciji z zaklepanjem dokumenta. Vsi trije naši protokoli temeljijo na optimističnem nadzoru sočasnosti. Kljub učinkovitosti protokolov se vseeno najde kakšna nezaželjena zadeva.

Poglejemo si specifičen primer sočasnega brisanja istega znaka v dokumentu pri uporabi OT. Recimo, da imamo dokument z nekaj deset znaki. Urejata ga uporabnika Alja in Bine. Oba naenkrat pobrišeta četrti znak in v istem času odpošljeta svoji spremembi {\tt \{ Pobriši @4 \}}. Na strežnik bosta obe spremembi prišli hkrati, vendar se bosta sprocesirali ena za drugo. Recimo, da se bo najprej sprocesirala Aljina sprememba. Pobrisala bo četrti znak. Alji bo nazaj poslana potrditev o uspešnem izbrisu, Binetu pa zahteva za brisanje četrtega znaka. Nato začne strežnik procesirati Binetovo spremembo, v kateri piše, naj se pobriše četrti znak. Res se pobriše trenutno četrti znak, ampak to ni isti znak, ki ga je izbrisal Bine v svojem lokalnem dokumentu. Ne strežniku se dejansko pobriše znak, ki ga ima Bine v svojem lokalnem dokumentu na petem mestu. Potrditev o uspešnem izbrisu se pošlje Binetu, Alji pa zahteva za brisanje četrega znaka. Podobno kot na strežniku se tudi tako v Aljinem kot Binetovem lokalnem dokumentu še enkrat pobriše četrti znak. Končni rezultat v vseh dokumentih sta pobrisana četrti in peti znak, čeprav sta Alja in Bine želela pobrisati le četrti znak.

Še en primer ne najboljše rešitve algoritma je pri protkolu WOOT. Predstavljajmo si uporabnike Aljo (217), Bineta (558) in Ceneta (609), ki urejajo dokument. Številka v oklepaju predstavlja posameznega uporabnika. Alja in Bine istočasno na isto mesto vpišeta vsak svojo začetnico imena. Alja naredit spremembo {\tt \{ Vstavi ‘t’$\prec$‘a’$\prec$‘d’ \}}, Bine pa {\tt \{ Vstavi ‘t’$\prec$‘b’$\prec$‘d’ \}}. Ne pozabimo, da nosi sprememba informacijo, med katerima dvema znakoma se mora vstaviti uporabnikov znak. Kot vidimo se vstavljanje integrira med črki “{\tt t}” in “{\tt d}”.  Vsak pošlje svojo spremembo Cenetu. On obe spremembi sprejme. Najprej začne procesirati Binetovo spremembo, vstavljanje črke “{\tt b}”. Le-ta se integrira brez težav. Nato začne procesirati Aljino spremembo, vstavljanje črke “{\tt a}”. Vstaviti se mora med črki “{\tt t}” in “{\tt d}”, med katerima dvema se že nahaja “{\tt b}”. Črka “{\tt a}” bi se lahko vstavila pred “{\tt b}” ali za “{\tt b}”. Ker je Aljina številka 217 manjša od Binetove 557, se črka “{\tt a}” vstavi pred črko “{\tt b}”. Rešitev je sicer enostavna, vendar daje ta način vedno prednost uporabnikom z nižjo številko pred tistim z višjo. Priviligiranost enega uporabnika pred drugimi bi lahko rešili z uro oziroma s časovnimi žigi. Pri integraciji sprememb pri odaljenem uporabiku bi lahko istoležeče spremembe razvrščali glede na vrstni red procesiranja. Kasneje sprocesirani znak bi moral ležati bolj desno. To je sicer rešitev z enakopravnim razvščanjem sprememb, vendar nam podre konsistentnost pri drugih uporabnikih, zato je rešitev neuporabna. Druga rešitev je, da uporabnik sam pošlje kdaj je naredil spremembo. Skupaj s spremembo se torej pošlje tudi časovni žig spremembe. Istoležeče spremembe se bi tako razvrščale glede na časovni žig. To zahteva natančno usklajenost ure pri vseh oddaljenih uporabnikih. Že to je precej težko doseči, poleg tega pa lahko uporabnik tudi goljufa, kdaj je naredil spremembo. Tako si ustvari priviligiran položaj.

Kot vidimo, ima OT težave s sočasnostjo istoležečih sprememb pri kombinaciji “{\tt Pobriši-Pobriši}”, WOOT pa pri kombinaciji “{\tt Vstavi-Vstavi}”. DS nima izrazitih težav.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zahtevnost protokola}

Zahtevnost protokola oziroma algoritma je širok pojem. Objektivno gledano bi lahko ta pojem zajel, koliko procesorske moči porabi posamezen algoritem. Eden izmed načinov merjenja zahtevnosti je, koliko časa bi potrebovali za njegovo implementacijo. Veliko bolj subjektivna ocena je, kako lahko oziroma kako težko je algoritem razumeti. Ljudje imamo različno predznanje. Nek algoritem je za nekoga lažje razumljiv, medtem ko je isti algoritem za drugega težje razumljiv. Če pa imamo statistične podatke dovolj velikega vzorca anketirancev, lahko iz njega povzamemo objektivne podatke. Naredil sem raziskavo med prijatelji, ki imajo podobno računalniško znanje, kot ga imam jaz. Navodila so bila sledeča: “V tretjem poglavju moje diplomske naloge na primeru opisujem protokole oziroma algortime za sodelovanje v realnem času. To so Diferenčna sinhronizacija, Operativna transformacija in Brez operativne transformacije. Potreboval bi tvojo pomoč. Cilj je, da si prebereš tretje poglavje in na koncu primerjaš protokole po zahtevnosti (razumljivosti). Najtežjemu daj 3 točke, srednje težkemu 2 točki in najlažjemu 1 točko.” Dobil sem 14 razporeditev 14 ljudi. Točke, ki so jih prejeli posamezni protokoli, si sledijo: DS 35 točk, OT 26 točk in WOOT 17 točk. To nam pove, da je algoritem DS najbolj zahteven za razumevanje, OT lažji in WOOT najlažje razumljiv. Vzorec anketirancev je res majhen, vendar se že pri tako majhnem vzorcu kažejo očitne razlike o zahtevnosti. Tudi moje subjektivno mnenje je, da je vrstni red zahtevnosti protokolov isti, kot sem ga dobil v moji raziskavi.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Iskanje razlik}
\label{chp:diff}

Algoritmi za iskanje razlik v besedilu se uporabljajo za zaznavanje sprememb, ki nastanejo, ko uporabnik ureja besedilo. Preprost primer razlike med dvema besediloma je prikazan na Sliki \ref{diff}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=10cm]{diff.png}
\end{center}
\caption{Primer razlike. Prečrtane črke so črke, ki so bile v izvirnem besedilu izbrisane, podčrtane črke pa dodane.}
\label{diff}
\end{figure}

Raziskave na tem področju so se začele že pred pojavom sodelovanja v realnem času na spletu in so jih obširno proučevali \cite{f-cmpr, o-nd, o-np} (kasneje \cite{diffstrg}). Namen vseh raziskav je bil, da se izboljša časovna zahtevnost algoritma za iskanje razlik. V čem je problem? Medtem ko uporabnik tipka, se morajo spremembe v najkrajšem možnem času poslati na strežnik. Če bi bil algoritem počasen in bi zamujal več sekund ali celo minut, bi bila uporabniška izkušnja zelo slaba. Pri večminutni zamudi že težko govorimo o sodelovanju uporabnikov v realnem času.

Besedilo, ki je skupno tako izvirnemu kot tudi spremenjenemu besedilu, imenujemo najdaljše skupno zaporedje (ang. longest common subsequence). V našem primeru to zaporedje sestavljajo črke “{\tt Leloil}”. Na Sliki \ref{diff} so to črke v razliki, ki niso ne prečrtane ne podčrtane. Med izvirnim in spremenjenim besedilom lahko izračunamo tudi najmanjšo razdaljo urejanja (ang. minimum edit distance), poimenovano tudi Levenshteinova razdalja (ang. Levenshtein distance). To je številka, ki pove, koliko sprememb bi morali narediti na izvirnem besedilu, da dobimo spremenjeno besedilo. Najmanjša razdalja urejanja našega primera je 12. Na Sliki \ref{diff} lahko vidimo pet prečrtanih in sedem podčrtanih črk. Skupaj torej 12 sprememb, petkrat brisanje in sedemkrat vstavljanje. Na podlagi najdaljšega skupnega zaporedja in najmanjše razdalje urejanja lahko predvidimo scenarij najkrajšega urejanja (ang. shortest edit script). To bi bili {\tt \{ Pobriši ‘do’ \}}, {\tt \{ Vstavi ‘ta’ \}}, {\tt \{ Pobriši ‘m’ \}}, {\tt \{ Vstavi ‘nos’ \}}, {\tt \{ Pobriši ‘ec’ \}}, {\tt \{ Vstavi ‘ka’ \}}. Ali so to res operacije, kot jih je naredil uporabnik, ne vemo. Dejstvo pa je, da so to spremembe v besedilu. Uporabnik bi lahko v celoti pobrisal besedo “{\tt Ledolomilec}” in na novo napisal “{\tt Letalonosilka}”. Problem, ki ga rešujemo, je zagotavljanje konsistentnosti med uporabniki. Ne zanima nas, katere operacije so se zgodile v urejevalniku. Ni pomembno, kako je uporabnik uredil besedilo, pomembna je njegova vsebina. Zato je dovolj, da ugotavljamo le, kakšne so spremembe v besedilu in ne, kako smo prišli do njih.

V nadaljevanju bomo na primeru prikazali, kako poisakati \textbf{nadaljše skupno zaporedje}, kako izračunati \textbf{najmanjšo razdaljo urejanja} in kako priti do \textbf{scenarija najkrajšega urejanja}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Najdaljše skupno zaporedje}
\label{sec:lcs}

Iskanje najdaljšega skupnega zaporedja bomo prikazali tabelarično \cite{lcs}, kot je prikazano na Sliki \ref{lcs1}. 

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{lcs1.png}
\end{center}
\caption{Priprava na iskanje najdaljšega skupnega zaporedja.}
\label{lcs1}
\end{figure}

Horizontalno na vrh tabele vpišemo daljšega od besedil, ki ju primerjamo. V našem primeru je to spremenjeno besedilo “{\tt Letalonosilka}”. Ima  {\tt n=13} znakov. Vsak znak je označen s številko od 1 do 13. Vertikalno ob tabeli vpišemo krajšega od besedil, to je izvirno besedilo “{\tt Ledolomilec}”. Ima  {\tt m=11} znakov. Vsak znak je označen s številko od 1 do 11. Zgornjo ničto vrstico in levi ničti stolpec zapolnimo z ničlami. To lahko naredimo zaradi logičnega razloga. Če katerokoli besedilo primerjamo s praznim besedilom, ti dve besedili nimata skupnega zaporedja.

Postopek za iskanje najdaljšega skupnega zaporedja se prične v zgornjem levem polju {\tt (1,1)} in se nadaljuje do konca vrstice. Nato gre v naslednjo vrstico, se ponovi za vse vrstice in se konča v spodnjem desnem polju {\tt (11,13)}. V vsakem polju v tabeli se primerja črki, ki pokrivata to polje. Če sta črki enaki, se v polje vpiše za eno večje število, kot je v zgornje-levo ležečem polju. Med ta dva polja se vriše še tako imenovani mostiček (ang. bridge). Če sta črki različni, se v polje vpiše večjega od zgornje ali levo ležečega polja.

Vsa polja {\tt (i,j)} v tabeli bomo zapolnili s številkami od 0 do števila znakov, ki se ujemajo v obeh besedilih.
Začnimo v polju {\tt (1,1)}. Primerjamo črki “{\tt L}” in “{\tt L}”. Ker sta črki enaki in je v zgornje-levo ležečem polju {\tt (0,0)} ničla, se v polje {\tt (1,1)} vpiše 1. Med polja {\tt (0,0)} in {\tt (1,1)} vrišemo mostiček. Nadaljujemo s poljem {\tt (1,2)}. Črki “{\tt L}” in “{\tt e}” sta različni. Vrednost levo ležečega polja {\tt (1,1)} je 1, kar je več od zgornje ležečega polja {\tt (0,2)}, ki je 0. V polje {\tt (1,2)} se torej vpiše vrednost 1. Slika \ref{lcs2} prikazuje izpolnjena prva dva polja.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{lcs2.png}
\end{center}
\caption{Izgled tabele po prvih dveh korakih.}
\label{lcs2}
\end{figure}

Ker se črka “{\tt L}” v besedi “{\tt Letalonosilka}” ne ponovi več, je v vseh poljih v prvi vrstici vrednost 1. Nadaljujemo v drugi vrstici. Pričnemo v polju {\tt (2,1)}. Ker sta črki “{\tt e}” in “{\tt L}” različni, se v polje {\tt (2,1)} vpiše večja od vrednosti levo ležečega polja {\tt (2,0)} 0 in zgornje ležečega polja {\tt (1,1)} 1, torej 1. Postopek se nadaljuje v polju {\tt (2,2)}. Črki “{\tt e}” in “{\tt e}” sta enaki. Vrednost zgornje-levo ležečega polja {\tt (1,1)} je 1. V polje {\tt (2,2)} se vpiše za 1 večja vrednost, torej 2. Doriše se mostiček. Glej Sliko \ref{lcs3}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{lcs3.png}
\end{center}
\caption{Pri primerjavi besedil smo našli že dve skupni črki.}
\label{lcs3}
\end{figure}

Po opisanem postopku nadaljujemo čez vse vrstice. Pazljivi moramo biti pri črkah, ki se v besedi ponovijo dvakrat, kot recimo črka “{\tt o}”. Izpolnjena tabela je na koncu taka, kot je prikazano na Sliki \ref{lcs4}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{lcs4.png}
\end{center}
\caption{Izpolnjena tabela po postopku za iskanje najdaljšega skupnega zaporedja.}
\label{lcs4}
\end{figure}

V spodanjem desnem polju {\tt (m,n)}, to je {\tt (11,13)}, se nahaja vrednost 6. To pomeni, da je v besedah, ki smo ju primerjali, najdaljše skupno zaporedje dolgo 6 znakov. Vprašanje je, kateri znaki ga sestavljajo. Opazimo nekaj zanimivega. Ustvarili smo otočke (ang. islands) številk od 1 do 6. Na Sliki \ref{lcs5} smo jih poudarili z debelejšo črto, ki predstavlja mejo otočka. Ti otočki so povezani v mostički. Da bo bomo izvedeli, kateri znaki sestavljajo najdaljše skupno zaporednje, bomo morali potovati od spodnjega desnega polja vse do zgornjega levega polja. Premikamo se v levo vse do leve meje otočka, nato navzgor vse do zgornje meje otočka. Pri mostičku prestopimo mejo in ponovimo postopek. Na ta način pridemo vse do zgornjega levega polja. Glej Sliko \ref{lcs5}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{lcs5.png}
\end{center}
\caption{Označena pot je razlika med izvirnim in spremenjenim besedilom.}
\label{lcs5}
\end{figure}

Označena pot od polja {\tt (0,0)} do {\tt (11,13)} predstavlja razliko, ki smo jo omenili v Sliki \ref{diff}. Diagonalne črtice (mostički) nam povedo, da se tiste črke v besedilu niso spremenile in predstavljajo najdaljše skupno zaporedje “{\tt Leloil}”.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Najmanjša razdalja urejanja}
\label{sec:med}

Iskanje najmanjše razdalje urejanja {\tt D(i,j)} bomo prikazali po korakih. Pripravimo si tabelo, kot je prikazano na Sliki \ref{med1}.

Horizontalno na vrh tabele vpišemo daljšega od besedil, ki ju primerjamo. Vertikalno ob tabeli vpišemo krajšega od besedil. V prvem koraku je tabela zelo podobna tabeli na Sliki \ref{lcs1}. Razlika je v ničti vrstici in v ničtem stolpcu. Zgornjo ničto vrstico zapolnimo z vrednostmi od 0 do {\tt n}. Vrednost {\tt n=13} predstavlja daljše od obeh besedil. Levi ničti stolpec zapolnimo z vrednostmi od 1 do {\tt m}. Vrednost {\tt m=11} in predstavlja krajše od obeh besedil. To lahko naredimo zaradi logičnega razloga. Če katerokoli besedilo primerjamo s praznim besedilom, je število operacij enako številu vseh vstavljanj oziroma vseh brisanj, da besedili poenotimo.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{med1.png}
\end{center}
\caption{Priprava na iskanje najmanjše razdalje urejanja.}
\label{med1}
\end{figure}

Postopek za iskanje najmanjše razdalje urejanja se prične v zgornjem levem polju {\tt (1,1)} in se nadaljuje do konca vrstice. Nato gre v naslednjo vrstico, se ponovi za vse vrstice in se konča v spodnjem desnem polju {\tt (11,13)}. Vrednost vsakega polja v tabeli je odvisna od vrednosti sosednjih treh polj. V posamezno polje se vpiše minimum od treh vrednosti. To so vrednost levo ležečega polja {\tt +1}, vrednost zgornje ležečega polja {\tt +1} ali vrednost zgornje-levo ležečega polja {\tt +2}, če sta polji različni, ali {\tt +0}, če sta polji enaki. Matematično to zapišemo, kot je prikazano na Sliki \ref{med2}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{med2.png}
\end{center}
\caption{Izračun najmanjše razdalje urejanja \cite{med}, pri čemer {\tt X(i)} predstavlja i-ti znak v krajšem (izvirnem) besedilu in {\tt Y(j)} predstavlja j-ti znak v daljšem (spremenjenem) besedilu. Opomba! Pri iskanju vrednosti {\tt D(i,j)} nad diagonalo z oznako {\tt $\Delta$} (glej Sliko \ref{ses1}) lahko upoštevamo le vrednosti levo ležečega polja in zgornje-levo ležečega polja. Zgornje ležeče polje bistveno ne vpliva na izračun. Pri iskanju vrednosti {\tt D(i,j)} pod diagonalo z oznako {\tt 0} lahko upoštevamo le vrednosti zgornje ležečega polja in zgornje-levo ležečega polja. Levo ležeče polje bistveno ne vpliva na izračun.}
\label{med2}
\end{figure}

\pagebreak

Začnimo v polju {\tt (1,1)}. Primerjamo črki “{\tt L}” in “{\tt L}”. Ker so vrednosti, ki jih pridobimo iz sosednjih treh polj enake {\tt 2} in {\tt 0} in {\tt 2}, se v polje {\tt (1,1)} vpiše najmanjša od vrednosti, to je 0. Nadaljujemo s poljem {\tt (1,2)}. Vrednosti, ki jih dajo sosednja tri polja, so enake {\tt 1} in {\tt 3} in {\tt 3}. Na mesto {\tt (1,2)} vpišemo 1. Izgled tabele po dveh korakih je prikazan na Sliki \ref{med3}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{med3.png}
\end{center}
\caption{Izgled tabele po prvih dveh korakih.}
\label{med3}
\end{figure}

Postopek nadaljujemo do konca prve vrstice. Ker se črka “{\tt L}” v besedilu “{\tt Letalonosika}” ne ponovi več, je vrednost vsakega nadaljnjega polja za eno večja od levo ležečega polja. Postopek ponovimo še čez vse vrstice. Slika \ref{med4} prikazuje v celoti izpolnjeno tabelo.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{med4.png}
\end{center}
\caption{Izgled tabele po postopku za iskanje najmanjše razdalje urejanja.}
\label{med4}
\end{figure}

V spodnjem desnem polju smo dobili vrednost {\tt D(11,13) = 12}. Tako smo napovedali tudi na začetku Poglavja \ref{chp:diff}, sedaj pa smo to vrednost tudi izračunali preko prikazanega postopka.

Ironično je, da bi lahko najmanjšo razdaljo urejanja med besedama “{\tt Ledolomilec}” in “{\tt Letalonosilka}” razbrali že pri iskanju najdaljšega skupnega zaporedja. Če pogledamo Sliko \ref{lcs5}, lahko pridemo do zanimive ugotovitve. Vertikalne črtice predstavljajo pobrisane črke iz izvirnega besedila. Horizontalne črtice predstavljajo vstavljene črke v spremenjenemu besedilu. Najmanjša razdalja urejanja je po definiciji minimalno število operacij, ki jih moramo narediti na izvirnem besedilu, da dobimo spremenjeno besedilo. Vseh vertikalnih in horizontalnih črtic na Sliki \ref{lcs5} je ravno 12.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Scenarij najkrajšega urejanja}
\label{sec:ses}

Scenarij najkrajšega urejanja lahko izluščimo iz tabele na Sliki \ref{lcs5}. Le sprehoditi bi se morali po najdeni poti. Težava je, da je časovna zahtevnost iskanje najdaljšega skupnega zaporedja, ki smo ga prikazali v Poglavju \ref{sec:lcs}, enaka {\tt O(nm)}, kjer sta {\tt n} in {\tt m} dolžini \linebreak besedil. Pri dolgih besedilih bi bil v praksi tak algoritem zelo počasen in neučinkovit. Namen tega poglavja je, da predstavimo izboljšan algoritem \cite{o-np} s časovno zahtevnostjo {\tt O(np)} v najslabšem možnem primeru, pri čemer je {\tt p=d/2-$\Delta$/2}. Število {\tt $\Delta$=n-m}, kjer je {\tt n} dolžina daljšega besedila in {\tt m} dolžina krajšega besedila. Število {\tt d} je najmanjša razdalja urejanja, ki smo jo izračunali v Poglavju \ref{sec:med}. Ideja izboljšanja algoritma je v optimizaciji iskanja poti od izvira (ang. source) v točki {\tt (0,0)} do ponora (ang. sink) v točki {\tt (n,m)}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{ses1.png}
\end{center}
\caption{Priprava na iskanje scenarija najkrajšega urejanja z označenimi diagonalami.}
\label{ses1}
\end{figure}

Označimo diagonalna polja {\tt k} z oznako od {\tt -m} do {\tt n}, kot je prikazano s krogci na Sliki \ref{ses1}. Označili smo pas med diagonalo {\tt k=0} in {\tt k=$\Delta$=n-m=2}. Prva diagonala poteka skozi izvir, druga pa skozi ponor. Če bi bili besedili identični, bi se ti dve diagonali prekrivali. Po tej diagonali pa bi potekala tudi pot, ki smo jo našli v Sliki \ref{lcs5}. Glede na to, da sta v našem primeru besedili različni, to pomeni, da bo pot potekala po označenem pasu in v njegovi bližini. Koliko se bo pot oddaljila od označenega pasa, je odvisno od vrednosti {\tt p}. Ker vrednosti {\tt p} v začetku algorima ne poznamo, jo moramo računati za vsako polje sproti. Na začetku tega poglavja smo rekli, da je vrednost {\tt p=d/2-$\Delta$/2}. To drži, vendar le za spodnje desno polje {\tt (n,m)}. Posamezno polje znotraj tabele se računa na način, ki je prikazan na Sliki \ref{ses2}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=10cm]{ses2.png}
\end{center}
\caption{Računanje vrednosti {\tt p} med postopkom.}
\label{ses2}
\end{figure}

Levi ničti stolpec zapolnimo z vrednostimi od 1 do {\tt m}. Vrednost {\tt m=11} predstavlja krajšega od obeh besedil. Pri zgornji ničti vrstici imamo manjšo posebnost. Polja znotraj obarvanega pasu (glej Sliko \ref{ses1}) zapolnimo z vrednostimi 0. Vrednost vsakega nadaljnjega polja v ničti vrstici pa je za eno večja od levo ležečega polja. Zadnje polje v ničti vrstici mora imeti vrednost {\tt m=11}.

Podobno kot v Poglavjih \ref{sec:lcs} in \ref{sec:med} se išče vrednosti polj v tabeli od leve proti desni in od zgoraj navzdol. Bistvena razlika je, da ne iščemo vedno do konca vrstice in ne začnemo vedno iskati na začetku vrstice. Iskanje poti bomo torej optimizirali tako, da bomo namesto vseh polj v tabeli raziskali samo tiste, ki so možni kandidati za pot (scenarij najkrajšega urejanja). Prične se v zgornjem levem polju {\tt (1,1)} z vrednostjo {\tt p=0}. Ko najdemo v tabeli vsa polja z vrednostjo {\tt 0}, začnemo iskati polja z vrednostjo {\tt 1}. Ko najdemo v tabeli vsa polja z vrednostjo {\tt 1}, začnemo iskati polja z naslednjo vrednostjo. Postopek ponavljamo, dokler ne dosežemo spodnjega desnega polja {\tt (n,m)}.

Smiselno se je vprašati, kako ve algoritem, da v tabeli ne obstaja nobeno polje s trenutno vrednostjo {\tt p}, ne da bi preiskali celotno tabelo. Kot bomo na koncu videli, so vrednosti polj na posamezni diagonali vedno naraščajoče. V praksi v našem primeru to pomeni (glej Sliko \ref{ses1}), da bodo imele polja na diagonalah z oznakami {\tt 0},{\tt 1} in {\tt 2} vrednosti {\tt 0} ali več. Polja na diagonalah z oznakami {\tt -1} in {\tt 3} bodo imela vrednosti {\tt 1} ali več. Polja na diagonalah z oznakami {\tt -2} in {\tt 4} pa vrednost {\tt 2} ali več itd. Na podlagi tega dejstva, je algoritem pri iskanju vrednosti {\tt p} omejen z robnimi diagonalami.

\pagebreak

Začnimo torej v zgornjem levem polju. Vrednost polja {\tt (1,1)} po formuli na Sliki \ref{ses2} je {\tt p(1,1)=0}. Nadaljujemo proti koncu vrstice. Vrednosti polj {\tt (1,2)} in {\tt (1,3)} sta tudi {\tt p=0}. Vrednost naslednjega polja nas ne zanima več. Zakaj? Zadnja vrednost {\tt p} na diagonali z oznako {\tt 3} je {\tt 1}, kar je več od trenutno iskanih polj z vrednostjo {\tt p=0}. Nadaljujemo v naslednjo (drugo) vrstico. Prvo polje (2,1) lahko izpustimo, saj je zadnja vrednost na diagonali z oznako {\tt -1} že {\tt 1}, kar je več od trenutno iskanih polj z vrednostjo {\tt p=0}. Nadaljujemo po vrstici. Izračunamo, da imajo naslednja tri polja {\tt (2,2)}, {\tt (2,3)} in {\tt (2,4)} vrednost {\tt p=0}. Polje {\tt (2,5)} nas trenutno ne zanima. Nadaljujemo v naslednjo (tretjo) vrstico. Ugotovimo, da moramo za polja z vrednostjo {\tt p=0} iskati le na diagonalah z oznako {\tt 0}, {\tt 1} in {\tt 2}. V tretji vrstici na teh diagonalah ne obstaja nobeno polje več, ki bi imelo vrednost {\tt p=0}. Po iskanju polj z vrednostjo {\tt p=0} izgleda naša tabela, kot je prikazano na Sliki \ref{ses3}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{ses3.png}
\end{center}
\caption{V tabeli smo našli vsa polja, ki imajo vrednost {\tt p=0}.}
\label{ses3}
\end{figure}

\pagebreak

Nadaljujemo z iskanjem polj v tabeli, ki imajo vrednost {\tt p=1}. Ta polja se lahko v našem primeru nahajajo le na diagonalah z oznakami od {\tt -1} do {\tt 3}. Po iskanju polj z vrednostjo {\tt p=1} izgleda naša tabela, kot je prikazano na Sliki \ref{ses4}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{ses4.png}
\end{center}
\caption{V tabeli smo našli vsa polja, ki imajo vrednost {\tt p=1}.}
\label{ses4}
\end{figure}

Nadaljujemo z iskanjem polj v tabeli, ki imajo vrednost {\tt p=2}. Ta polja se lahko v našem primeru nahajajo le na diagonalah z oznakami od {\tt -2} do {\tt 4}. Po iskanju polj z vrednostjo {\tt p=2} izgleda naša tabela, kot je prikazano na Sliki \ref{ses5}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{ses5.png}
\end{center}
\caption{V tabeli smo našli vsa polja, ki imajo vrednost {\tt p=2}.}
\label{ses5}
\end{figure}

\pagebreak

Nadaljujemo z iskanjem polj v tabeli, ki imajo vrednost {\tt p=3}. Ta polja se lahko v našem primeru nahajajo le na diagonalah z oznakami od {\tt -3} do {\tt 5}. Po iskanju polj z vrednostjo {\tt p=3} izgleda naša tabela, kot je prikazano na Sliki \ref{ses6}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{ses6.png}
\end{center}
\caption{V tabeli smo našli vsa polja, ki imajo vrednost {\tt p=3}.}
\label{ses6}
\end{figure}

Nadaljujemo z iskanjem polj v tabeli, ki imajo vrednost {\tt p=4}. Ta polja se lahko v našem primeru nahajajo le na diagonalah z oznakami od {\tt -4} do {\tt 6}. Po iskanju polj z vrednostjo {\tt p=4} izgleda naša tabela, kot je prikazano na Sliki \ref{ses7}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{ses7.png}
\end{center}
\caption{V tabeli smo našli vsa polja, ki imajo vrednost {\tt p=4}.}
\label{ses7}
\end{figure}

\pagebreak

Nadaljujemo z iskanjem polj v tabeli, ki imajo vrednost {\tt p=5}. Ta polja se lahko v našem primeru nahajajo le na diagonalah z oznakami od {\tt -5} do {\tt 7}. Po iskanju polj z vrednostjo {\tt p=5} izgleda naša tabela, kot je prikazano na Sliki \ref{ses6}.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{ses8.png}
\end{center}
\caption{V tabeli smo našli vsa polja, ki imajo vrednost {\tt p=5}.}
\label{ses8}
\end{figure}

Postopek se zaključi, ko najdemo v spodnjem desnem polju {\tt (n,m)} vrednost {\tt p}. V našem primeru je {\tt p(11,13)=5}. Če primerjamo Sliko \ref{lcs5} in Sliko \ref{ses8}, lahko opazimo, da pot iz Slike \ref{lcs5} res poteka po obarvanih poljih na Sliki \ref{ses8}. Privarčevali smo računanje vrednosti nekaterih polj v zgornjem desnem in v spodnjem levem delu tabele. V našem primeru je to le manjši del tabele. V praksi se izkaže, da je pri urejanju besedila to večji del tabele, saj se iskana pot razlike besedil vedno nahaja v pasu med diagonalama z oznako {\tt -p} in {\tt $\Delta$+p}.

Do \textbf{scenarija najkrajšega urejanja} pridemo preko najdaljšega skupnega zaporedja, ki smo ga poiskali v Poglavju \ref{sec:lcs} in prikazali na Sliki \ref{lcs5}. V trenutnem Poglavju \ref{sec:ses} smo preko vrednosti {\tt p} predstavili, kako optimizirati iskanje poti. V praksi se morajo vsi ti izračuni (\textbf{najdaljše skupno zaporedje}, \textbf{najmanjša razdalja urejanja} in \textbf{vrednost p}) pri primerjavi podbesedil računati sočasno tekom algoritma, saj le na ta način najbolje optimiziramo časovno zahtevnost.

\pagebreak

Šele na koncu, ko imamo Sliko \ref{ses9}, se sprehodimo po poti in izluščimo scenarij najkrajšega urejanja.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=8cm]{ses9.png}
\end{center}
\caption{Optimizirano iskanje najdaljšega skupnega zaporedja.}
\label{ses9}
\end{figure}

Spremembe na besedilu so torej {\tt \{ Pobriši @3-4 \}}, {\tt \{ Vstavi ‘ta’ @5 \}}, {\tt \{ Pobriši @7-7 \}}, {\tt \{ Vstavi ‘nos’ @8 \}}, {\tt \{ Pobriši @10-11 \}}, {\tt \{ Vstavi ‘ka’ @12 \}}. Lokacije vseh sprememb temeljijo na izvirnem besedilu “{\tt Ledolomilec}”.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementacija urejevalnika}

Odločili smo se, da bomo urejevalnik v realnem času zasnovali kot enostavno spletno aplikacijo. Dostop do urejevalnika smo omejili le na dodeljene uporabniške račune. Ko se uporabnik prijavi v spletno aplikacijo, ga na osrednjem delu zaslona pričaka polje za vnos besedila, ki ga lahko ureja več uporabnikov. Na desni strani zaslona pa si lahko ogleda zgodovino vseh sprememb, ki so bile narejene na besedilu.

Na strani strežnika smo uporabili platformo \textbf{node.js}. To je platforma za enostavno izdelavo hitrih in razširljivih spletnih aplikacij. Uporablja dogodkovno-gnan, ne-blokirajoč model, ki je perfekten za podatkovno intenzivne aplikacije v realnem času. Uporabniške račune hranimo v podatkovni bazi RethinkDB. Sama prijava je v brskalniku realizirana s knjižnico AngularJS. Sicer pa smo na strani odjemalca (v brskalniku) uporabili standardne tehnologije, to so HTML, CSS in JS. Za manipulacijo DOM drevesa in urejevalnika smo se posluževali še knjižnice jQuery.

Implementacija urejevalnika je potekala v treh korakih. V prvem koraku smo zasnovali aplikacijo in naredili prijavo. V drugem koraku smo se lotili iskanja razlik v besedilu. Na koncu smo realizirali še Operativno transformacijo. V opisu teh treh korakov se bomo sklicevali na nekatere datoteke. Bralca naprošamo, da si jih podrobno ogleda na GitHub-u (\url{https://github.com/eMarek/Revision}), kjer je dosegljiva celotna koda aplikacije.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zasnova in prijava}

Aplikacijo smo želeli zasnovati kot enostavno modularno ogrodje (ang. framework). Uporabnost modularne zasnove je, da se jo lahko enostavno razširi za uporabo kolaboracije, ki jo bomo opisali v Poglavju \ref{sec:imp-ot}. Glavni funkcionalnosti, ki ju naš modul omogoča, sta serviranje statičnih datotek ter zagotavljanje podatkov preko API-ja.

Kot lahko vidimo v datoteki “{\tt server.js}” v vrstici 91, se za vsak zahtevek na strežnik najprej pogleda ime poti. V primeru, da je prvih pet znakov enakih “{\tt /api/}”, zadnjih pet znakov enakih “{\tt .json}” in je metoda zahtevka “POST”, potem modul zagotovi gole podatke. V nasprotnem primeru poskuša odjemalcu vrniti statično datoteko iz javnega (ang. public) direktorija.

Za potrebo prijave smo implementirali še konfiguracijsko datoteko (ang. config) in krmilnik (ang. controller). Razlika med njima je, da se konfiguracijska datoteka požene le enkrat ob zagonu aplikacije, krmilnik pa se izvede ob vsakem zahtevku na strežniku. Iz tega razloga je konfiguracijska datoteka primerna za ustvarjanje povezave na bazo, krmilnik pa lahko uporabimo za preverjanje avtentikacije.

V konfiguracijski datoteki “{\tt example/config.js}” se v vrstici 17 naredi povezavo na bazo. Po uspešno ustvarjeni povezavi na bazo se pokliče funkcija “{\tt starter}”, ki požene spletni strežnik. V krmilniku v datoteki “{example/controller.js}” v vrstici 34 se sejo poskuša dekriptirati in nato pretvoriti v JSON obliko. V vrstici 71 se naredi klic na bazo in preveri, ali obstaja uporabik z ID-jem iz seje. V primeru, da je vse v redu se na koncu pokliče še funkcija “{\tt handler}”, ki glede na ime poti vrne podatke.

Da si lahko uporabnik sploh ustvari sejo, smo naredili API rokovalnik (ang. handler) v datoteki “{\tt example/api/default.js}” v vrstici 58. Uporabnik pošlje na strežnik svoje uporabniško ime in geslo. Geslo se pretvori v zgoščeno obliko. V podatkovni bazi se preveri, ali obstaja uporabnik s prispelim uporabniškim imenom in zgoščeno obliko gesla. V primeru, da obstaja, se uporabniku vrne zakriptirana seja, v kateri je med drugim shranjen uporabnikov ID. Uporabnikov brskalnik si sejo in uporabnikov ID shrani v skladišče seje (ang. session storage). Glej datoteko “{\tt example/public/js/application.js}” v vrsticah 85 in 86.

Na tak način je zasnovana naša aplikacija in realizirana prijava vanjo.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Iskanje razlik}

Iskanje razlik v besedilu smo realizirali po algoritmu, ki smo ga opisali v Poglavju \ref{chp:diff}, zato ga ne bomo ponovno. Celotna koda se nahaja v datoteki “{\tt changes.js}”. Na tem mestu omenimo le, na kakšen način se vrnejo razlike. Funkcija za iskanje razlik vrne seznam (ang. array) JSON objektov.

Vsak objekt predstavlja eno razliko v besedilu in vsak objekt ima lastnost “{\tt a}”, ki pomeni akcijo (ang. action). Akcija je lahko vrednosti “{\tt +}” (dodajanje besedila) ali “{\tt -}” (brisanje besedila). Vsak objekt ima še lastnosti “{\tt s}”, ki predstavlja niz (ang. string) znakov, in “{\tt l}”, ki predstavlja dolžino (ang. length) niza znakov. V primeru, da gre za brisanje besedila, ima objekt še lastnosti “{\tt f}” in “{\tt t}”, ki pomenita od (ang. from) katere in do (ang. to) katere lokacije je potrebno pobrisati znake. V primeru, da gre za dodajanje besedila, pa ima objekt še lastnost “{\tt p}”, ki pomeni pozicijo (ang. position), na katero je potrebno dodati besedilo. Primer razlike med besedama “{\tt Ledolomilec}” in “{\tt Letalonosilka}” je prikazan v Primeru 6.1.\newline

\begin{lstlisting}[title={Primer 6.1: Razlike med besedama “{\tt Ledolomilec}” in “{\tt Letalonosilka}”.}]
[ { a: '-', s: 'do', l: 2, f: 3, t: 4 },
  { a: '+', s: 'ta', l: 2, p: 5 },
  { a: '-', s: 'm', l: 1, f: 7, t: 7 },
  { a: '+', s: 'nos', l: 3, p: 8 },
  { a: '-', s: 'ec', l: 2, f: 10, t: 11 },
  { a: '+', s: 'ka', l: 2, p: 12 } ]
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Operativna transformacija}
\label{sec:imp-ot}

Kot smo omenili že v Poglavju \ref{subsec:ps}, se Operativna tranformacija izvaja tako na strani strežnika kot na strani odjemalca. Koda za strežniški del Operativne transformacije se nahaja v datoteki “{\tt collaboration.js}”, koda Operativne transformacije pri odjemalcu pa v datoteki “{\tt example/public/js/collaboration.js}”. Algoritem je podoben (malenkost poenostavljen) tistemu, ki smo ga opisali v Poglavju \ref{sec:ot}. Ker je strežniški del enostavnejši, ga bomo opisali najprej.

Na strani strežnika si beležimo revizijski dnevnik (ang. revision diary), trenutni dokument (ang. current document) in uporabnike (ang. users). Strežnik od odjemalca pričakuje, da bo vedno dobil številko zadnje potrjene revizije ({\tt req.payload.revision}). V primeru, da odjemalec pošlje številko zadnje revizije {\tt -2}, se celotni urejevalnik resetira. V primeru, da odjemalec pošlje številko zadnje revizije {\tt -1}, ali v primeru, da uporabnik še ne obstaja, strežnik vrne odjemalcu podatke za inicializacijo urejevalnika. To so trenutni dokument, revizijski dnevnik in številka zadnje revizije.\newline

\begin{lstlisting}[title={Koda 6.2: Strežnik odjemalcu vrne podatke za inicializacijo urejevalnika.}]
var revisionDiary = [];
var currentDocument = "";
var users = {};

/* collaboration
-------------------------------------------------- */
module.exports = function collaboration(req, rsp, data) {

    // reset editor
    if (req.payload.revision == -2) {
        revisionDiary = [];
        currentDocument = "";
        users = {};
    }

    // forced initialization or new user
    if (req.payload.revision == -1 || !users.hasOwnProperty(data.user.id)) {

        // remember user
        users[data.user.id] = true;

        // respond with initialization data
        rsp.send({
            "currentDocument": currentDocument,
            "revisionDiary": revisionDiary,
            "revision": revisionDiary.length
        });

    } else {

        // more code here...
        // Koda 6.3
    }
};
\end{lstlisting}

Ko odjemalec pošlje strežniku nove spremembe oziroma natančneje popravke sprememb ({\tt req.payload.patch}), se morajo ti pravilno umestiti v trenutni dokument. Za vsak nov popravek moramo izračunati odmik, ki nastane s spremembami drugih uporabnikov. S popravkom, ki ima pravilne pozicije, posodobimo trenutni dokument in popravek shranimo v revizijski dnevnik. Ker tudi odjemalec od strežnika pričakuje, da bo vedno dobil številko zadnje revizije v revizijskem dnevniku, se mora le-ta poslati odjemalcu. V primeru, da so v revizijskem dnevniku nove spremembe, o katerih uporabnik še ni obveščen, se morajo poslati tudi te.\newline

\begin{lstlisting}[title={Koda 6.3: Izvajanje Operativne transformacije na strani strežnika.}]
// new incoming patches from current user
if (req.payload.patch) {

    // prepare bundle
    bundle = {..., "patch": req.payload.patch, ...};

    // calculate offset for incoming patch - OPERATIONAL TRANSFORMATION
    offset = 0;
    for (var rd in revisionDiary) {
        if (rd >= req.payload.revision) {

            // single revision diary patch
            patch = revisionDiary[rd].patch;

            // some characteres were added in previous revision
            if (patch.a === "+") {
                if (bundle.patch.a === "+" && bundle.patch.p >= patch.p) {
                    offset = offset + patch.s.length;
                }
                if (bundle.patch.a === "-" && bundle.patch.f >= patch.p) {
                    offset = offset + patch.s.length;
                }
            }

            // some characteres were deleted in previous revision
            if (patch.a === "-") {
                if (bundle.patch.a === "+" && bundle.patch.p >= patch.f) {
                    offset = offset - patch.s.length;
                }
                if (bundle.patch.a === "-" && bundle.patch.f >= patch.f) {
                    offset = offset - patch.s.length;
                }
            }
        }
    }

    // adding characters
    if (bundle.patch.a === "+") {

        // take offset into account
        bundle.patch.p = bundle.patch.p + offset;

        // update current document
        currentDocument = currentDocument.substr(0, bundle.patch.p - 1) + bundle.patch.s + currentDocument.substr(bundle.patch.p - 1);
    }

    // deleting characters
    if (bundle.patch.a === "-") {

        // take offset into account
        bundle.patch.f = bundle.patch.f + offset;
        bundle.patch.t = bundle.patch.t + offset;

        // update patch string just in case
        bundle.patch.s = currentDocument.substring(bundle.patch.f - 1, bundle.patch.t);

        // update current document
        currentDocument = currentDocument.substr(0, bundle.patch.f - 1) + currentDocument.substr(bundle.patch.t);
    }

    // push bundle to revision diary
    revisionDiary.push(bundle);
}

// do we have new patches in revision diary
if (revisionDiary.length > req.payload.revision) {
    rsp.send({
        "revisionDiary": revisionDiary.slice(req.payload.revision),
        "revision": revisionDiary.length
    });
} else {
    rsp.send({
        "revision": revisionDiary.length
    });
}
\end{lstlisting}

\pagebreak
Na strani odjemalca se Operativna transformacija izvaja podobno kot na strani strežnika. Razlika je le v nekaj dodatnih opravilih, ki jih mora opraviti odjemalec. Najprej mora poskrbeti, da se kolaboracija izvaja periodično na vsako desetinko. Po odgovoru strežnika pa mora poskrbeti, da se uporabnikova utripalka (ang. caret) po Operativni transformaciji postavi na pravo mesto. Uporabnik ne sme imeti občutka, da skače utripalka levo in desno po besedilu. Zagotviti mu moramo tekoče tipkanje.

Kolaboracija se dejansko izvedele le v primeru, da urejevalnik obstaja v DOM drevesu in ni čakajočih sprememb.\newline

\begin{lstlisting}[title={Koda 6.4: Periodično izvajanja kolaboracije.}]
setInterval(function() {

    // does editor exist on page
    if ($(editor).length) {

        // in case of waiting patches collaboration will call itself
        if (!waitingPatches[0]) {

            // fire collaboration
            collaboration();
        }
        
    } else {

        // reset collaboration
        revision = -1;
        // some more declarations here...
    }
}, 100);
\end{lstlisting}

Tekom kolaboracije se ponovno preveri, ali obstajajo čakajoče spremembe. Če jih ni, se poskuša s funkcijo za iskanje razlik v besedilu poiskati nove spremembe. V nadaljevanju algoritma se iz čakajočih sprememb vzame prvo in se jo pošlje na strežnik skupaj z revizijsko številko. Če ni čakajočih sprememb, se na strežnik pošlje le številko zadnje revizije, saj se tako preveri, ali je kakšno spremembo naredil kdo drug od uporabnikov. Klic na strežnik se naredi z AJAX klicem.

\pagebreak
\begin{lstlisting}[title={Koda 6.5: Iskanje sprememb v besedilu in AJAX klic na strežnik.}]
function collaboration() {

    // calculate waiting patches with changes function if there is non
    if (!waitingPatches[0]) {
        newDocument = $(editor).val();
        waitingPatches = changes(oldDocument, newDocument);
    }

    // sent patch to server if there is any
    if (waitingPatches[0]) {

        // take on patch from waiting patches and
        // sent it with expected revision number
        data = {
            "patch": waitingPatches.shift(),
            "revision": revision
        };
        
    } else {
        // sent just revision number to the server
        data = {
            "revision": revision
        };
    }

    // collaboration ajax
    xhr.collaboration = $.ajax({
        url: "api/collaboration.json",
        contentType: "application/json",
        type: "post",
        data: JSON.stringify(data),
        headers: {
            session: window.sessionStorage.session
        },
        dataType: "json",
        success: function(server) {
            // Koda 6.6
        }
    });
}
\end{lstlisting}

Potem ko odjemalec uspešno (ang. success) prejme strežnikov odgovor, mora sprocesirati revizijski dnevnik ({\tt server.revisionDiary}). V njem se nahajajo le nove spremembe od zadnje revizijske številke. Razlago Operativno transformacijo na strani odjemalca bomo izpustili, saj je podobna, kot smo jo opisali na strani strežnika. Nekaj več besed pa lahko namenimo pozicioniranju utripalke. Upoštevati je potrebno, da ima lahko uporabnik v urejevalniku del besedila kar označen (ang. highlighted). V tem primeru sta začetek in konec označbe (ang. selection start and end) različna, sicer pa enaka. Algoritem naredi zanko preko vseh potrjenih sprememb. Če avtor spremembe ni uporabnik sam, je potrebno izračunati odmik utripalke.

Pri dodajanju besedila sta torej dve varianti, pri katerih je potrebno popravljati pozicijo označenega dela. Besedilo se dodaja pred označen ali pa med označen del. V prvem primeru je potrebno popravljati tako začetek kot konec označbe, v drugem pa le konec označbe.

Pri brisanju besedila so štiri variante. Poleg omenjenih dveh se lahko besedilo briše ravno na mestu, kjer je začetek ali konec označbe. V primeru, da se besedilo briše na začetku označbe, se spremenita tako začetek kot konec. V primeru, da se besedilo briše na koncu označbe, se spremeni le konec.\newline

\begin{lstlisting}[title={Koda 6.6: Popravljanje pozicije utripalke na strani odjemalca.}]
// remember acknowledged patches prepare caret values
acknowledgedPatches = acknowledgedPatches.concat(server.revisionDiary);
caretStart = $(editor)[0].selectionStart;
caretEnd = $(editor)[0].selectionEnd;
caretOffsetStart = 0;
caretOffsetEnd = 0;

// loop
for (var lp in acknowledgedPatches) {
    patch = acknowledgedPatches[lp].patch;

    // if not my patch
    if (acknowledgedPatches[lp].author !== window.sessionStorage.userID) {
        // do OPERATIONAL TRANSFORMATION and correct waiting
        // patches position or from/to values here...

        // characteres were added in previous revision
        if (patch.a === "+") {
            if (...++++...[..........]..........) {
                caretOffsetStart = caretOffsetStart + patch.s.length;
                caretOffsetEnd = caretOffsetEnd + patch.s.length;
            }
            if (..........[...++++...]..........) {
                caretOffsetStart = caretOffsetStart;
                caretOffsetEnd = caretOffsetEnd + patch.s.length;
            }
        }

        // characteres were deleted in previous revision
        if (patch.a === "-") {
            if (...----...[..........]..........) {
                caretOffsetStart = caretOffsetStart - patch.s.length;
                caretOffsetEnd = caretOffsetEnd - patch.s.length;
            }
            if (........--[--........]..........) {
                caretOffsetStart = caretOffsetStart - (caretStart - patch.f);
                caretOffsetEnd = caretOffsetEnd - patch.s.length;
            }
            if (..........[...----...]..........) {
                caretOffsetStart = caretOffsetStart;
                caretOffsetEnd = caretOffsetEnd - patch.s.length;
            }
            if (..........[........--]--........) {
                caretOffsetStart = caretOffsetStart;
                caretOffsetEnd = caretOffsetEnd - (caretEnd - patch.f) - 1;
            }
        }
    }
}
// update current document here...
// put current document into the editor
$(editor).val(currentDocument);

// correct caret position with offset
$(editor)[0].selectionStart = caretStart + caretOffsetStart;
$(editor)[0].selectionEnd = caretEnd + caretOffsetEnd;

// revision
revision = server.revision;
\end{lstlisting}

Na koncu se trenutni dokument vpiše v urejevalnik in nastavi se pozicija utripalke oziroma označbe. Popravi se še številka zadnje revizije in kolaboracija se zaključi.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% sklpne ugotovitve
\chapter{Sklepne ugotovitve}

Cilj diplomske naloge je bil implementirati enega izmed algoritmov za urejenje besedila v realnem času in tako zasnovati urejevalnik. To nam je tudi uspelo. Aplikacija je enostavna za uporabo in prikazuje, kako napredna tehnologija omogoča in spodbuja sodelovanje oddaljenih uporabnikov. Večino testiranja smo naredili v brskalniku Google Chrome verzije 34.0, vendar aplikacija zelo dobro dela tudi na pametnih mobilnih telefonih in na tabličnih računalnikih.

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=14cm]{revision-login.png}
\end{center}
\caption{Prijava v aplikacijo, ki smo jo poimenovali “Revision”.}
\label{rev-lgn}
\end{figure}

\pagebreak

\vspace*{1cm}

\begin{figure}[placement h]
\begin{center}
\includegraphics[width=14cm]{revision-editor.png}
\end{center}
\caption{Urejevalnik in prikaz urejanja dveh uporabnikov.}
\label{rev-edt}
\end{figure}

V primerjavi z ostalimi podobnimi orodji (share.js) je naš urejevalnik bolj prilagodljiv. Le z malo spremembami lahko zamenjamo podatkovno bazo. To pomeni, da je naše orodje enostavno priključiti na že obstoječe projekte. Prednost našega orodja je tudi v vgrajeni avtentikaciji. Vsak uporabnik se mora za uporabo urejevalnika prijaviti. Razvijalcem, ki bi želeli naše orodje uporabiti in nadgraditi v končni produkt, ne bi bilo potrebno skrbeti še za avtentikacijo uporabnikov, saj je to že narejeno. Kot lahko vidimo na Sliki \ref{rev-edt}, smo v aplikacijo vgradili tudi prikaz sprememb, ki jih naredijo uporabniki v besedilu.

Tako kot vsako tehnologijo je mogoče tudi našo še izboljšati. Skoraj nujna potreba po izboljšavi je uporaba spletne vtičnice (ang. WebSocket), ki bi nadomestila periodične AJAX klice. Privarčevali bi kar nekaj procesorske moči tako na strani odjemalca kot na strani strežnika. Danes podpirajo spletne vtičnice že vsi novejši brskalniki, vendar smo zaradi želje po kompatibilnosti s starejšimi brskalniki uporabili AJAX klice.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% literatura
\addcontentsline{toc}{chapter}{Literatura}
\begin{thebibliography}{99}

\bibitem{ccigs} C.A. Ellis, S.J. Gibbs. “Concurrency Control in Groupware Systems”, 1989.
\\\url{http://www-ihm.lri.fr/~mbl/ENS/CSCW/2012/papers/Ellis-SIGMOD89.pdf}

\bibitem{hllbw} D. A. Nichols, P. Curtis, M. Dixon, J. Lamping. “High-Latency, Low-Bandwidth Windowing in the Jupiter Collaboration System”, 1995.
\\\url{http://lively-kernel.org/repository/webwerkstatt/!svn/bc/15693/projects/Collaboration/paper/Jupiter.pdf}

\bibitem{sigce} The Special Interest Group on Collaborative Computing, 1998.
\\\url{http://cooffice.ntu.edu.sg/sigce/}

\bibitem{wave-ot} D. Wang, A. Mah, S. Lassen. “Google Wave Operational Transformation”, 2010.
\\\url{http://www.waveprotocol.org/whitepapers/operational-transform}

\bibitem{wave-cs} J. Gregorio. “Google Wave Client-Server Protocol Whitepaper”, 2010.
\\\url{http://www.waveprotocol.org/whitepapers/internal-client-server-protocol}

\bibitem{share} J. Gentle. “ShareJS - Live concurrent editing in your app”, 2011.
\\\url{http://sharejs.org/}

\bibitem{node} Joyent, Inc., R. Dahl. “\textbf{node.js}”, 2009.
\\\url{http://nodejs.org/}

\bibitem{problem} The Dojo Fundation. “Open Cooperative Web Framework”, 2011.
\\\url{http://opencoweb.org/ocwdocs/intro/openg.html}

\bibitem{wiki} Wikipedia, the free encyclopedia. “Operational transformation”.
\\\url{http://en.wikipedia.org/wiki/Operational_transformation}

\bibitem{diffsync} N. Fraser. “Differential Synchronization”, 2009.
\\\url{https://neil.fraser.name/writing/sync/}

\bibitem{gdocs22} J. Day-Richter. “What’s different about the new Google Docs: Conflict resolution”, 2010.
\\\url{http://googledocs.blogspot.com/2010/09/whats-different-about-new-google-docs_22.html}

\bibitem{gdocs23} J. Day-Richter. “What’s different about the new Google Docs: Making collaboration fast”, 2010.
\\\url{http://googledocs.blogspot.com/2010/09/whats-different-about-new-google-docs_23.html}

\bibitem{woot} G. Oster, P. Urso, P. Molli, A. Imine. “Real time group editors without Operational transformation”, 2005.
\\\url{http://hal.inria.fr/docs/00/07/12/40/PDF/RR-5580.pdf}

\bibitem{p2p} Wikipedia, the free encyclopedia. “Peer-to-peer”.
\\\url{http://en.wikipedia.org/wiki/Peer-to-peer}

\bibitem{c-s} Wikipedia, the free encyclopedia. “Client–server model”.
\\\url{http://en.wikipedia.org/wiki/Client-server_model}

\bibitem{f-cmpr} W. Miller, E. W. Myers. “A File Comparison Program”, 1985.
\\\url{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.189.70&rep=rep1&type=pdf}

\bibitem{o-nd} E. W. Myers. “An O(ND) Difference Algorithm and Its Variations”, 1986.
\\\url{https://neil.fraser.name/software/diff_match_patch/myers.pdf}

\bibitem{o-np} S. Wu, U. Manber, G. Myers, W. Miller. “An O(NP) Sequence Comparison Algorithm”, 1989.
\\\url{http://www.itu.dk/stud/speciale/bepjea/xwebtex/litt/an-onp-sequence-comparison-algorithm.pdf}

\bibitem{diffstrg} N. Fraser. “Diff Strategies”, 2006.
\\\url{https://neil.fraser.name/writing/diff/}

\bibitem{lcs} D. Sodkiewicz. “Longest Common Subsequence Algorithm”, 2013.
\\\url{https://www.youtube.com/watch?v=P-mMvhfJhu8}

\bibitem{med} D. Jurafsky. “Computing Minimum Edit Distance”, 2012.
\\\url{http://www.youtube.com/watch?v=z_CB7Gih_Mg}

\end{thebibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}